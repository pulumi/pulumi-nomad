{
    "name": "nomad",
    "description": "A Pulumi package for creating and managing nomad cloud resources.",
    "keywords": [
        "pulumi",
        "nomad"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`nomad` Terraform Provider](https://github.com/hashicorp/terraform-provider-nomad).",
    "repository": "https://github.com/pulumi/pulumi-nomad",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing nomad cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-nomad)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-nomad` repo](https://github.com/pulumi/pulumi-nomad/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-nomad` repo](https://github.com/hashicorp/terraform-provider-nomad/issues).",
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-nomad)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-nomad` repo](https://github.com/pulumi/pulumi-nomad/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-nomad` repo](https://github.com/hashicorp/terraform-provider-nomad/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "address": {
                "type": "string",
                "description": "URL of the root of the target Nomad agent."
            },
            "caFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "caPem": {
                "type": "string",
                "description": "PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "certFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate provided to the remote agent; requires use of key_file or key_pem."
            },
            "certPem": {
                "type": "string",
                "description": "PEM-encoded certificate provided to the remote agent; requires use of key_file or key_pem."
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/nomad:config/headers:headers"
                },
                "description": "The headers to send with each Nomad request.",
                "secret": true
            },
            "httpAuth": {
                "type": "string",
                "description": "HTTP basic auth configuration."
            },
            "ignoreEnvVars": {
                "type": "object",
                "additionalProperties": {
                    "type": "boolean"
                },
                "description": "A set of environment variables that are ignored by the provider when configuring the Nomad API client."
            },
            "keyFile": {
                "type": "string",
                "description": "A path to a PEM-encoded private key, required if cert_file or cert_pem is specified."
            },
            "keyPem": {
                "type": "string",
                "description": "PEM-encoded private key, required if cert_file or cert_pem is specified."
            },
            "region": {
                "type": "string",
                "description": "Region of the target Nomad agent."
            },
            "secretId": {
                "type": "string",
                "description": "ACL token secret for API requests."
            },
            "skipVerify": {
                "type": "boolean",
                "description": "Skip TLS verification on client side."
            }
        },
        "defaults": [
            "address"
        ]
    },
    "types": {
        "nomad:config/headers:headers": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The header name\n"
                },
                "value": {
                    "type": "string",
                    "description": "The header value\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/AclAuthMethodConfig:AclAuthMethodConfig": {
            "properties": {
                "allowedRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - A list of allowed values\nthat can be used for the redirect URI.\n"
                },
                "boundAudiences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - List of auth claims that are\nvalid for login.\n"
                },
                "boundIssuers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - The value against which to match\nthe iss claim in a JWT.\n"
                },
                "claimMappings": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Mappings of claims (key) that will be copied to a metadata field (value).\n"
                },
                "clockSkewLeeway": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Duration of leeway when validating\nall claims in the form of a time duration such as \"5m\" or \"1h\".\n"
                },
                "discoveryCaPems": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - PEM encoded CA certs for use\nby the TLS client used to talk with the OIDC Discovery URL.\n"
                },
                "expirationLeeway": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Duration of leeway when validating\nexpiration of a JWT in the form of a time duration such as \"5m\" or \"1h\".\n"
                },
                "jwksCaCert": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - PEM encoded CA cert for use by the \nTLS client used to talk with the JWKS server.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - JSON Web Key Sets url for authenticating\nsignatures.\n"
                },
                "jwtValidationPubKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - List of PEM-encoded \npublic keys to use to authenticate signatures locally.\n"
                },
                "listClaimMappings": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Mappings of list claims (key) that will be copied to a metadata field (value).\n"
                },
                "notBeforeLeeway": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Duration of leeway when validating\nnot before values of a token in the form of a time duration such as \"5m\" or \"1h\".\n"
                },
                "oidcClientAssertion": {
                    "$ref": "#/types/nomad:index/AclAuthMethodConfigOidcClientAssertion:AclAuthMethodConfigOidcClientAssertion",
                    "description": "`(OIDCClientAssertion: \u003coptional\u003e)` - Optionally\nsend a signed JWT (\"[private key jwt][]\") as a client assertion to the OIDC\nprovider. Browse to the [OIDC concepts][concepts-assertions] page to learn\nmore.\n"
                },
                "oidcClientId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The OAuth Client ID configured\nwith the OIDC provider.\n"
                },
                "oidcClientSecret": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The OAuth Client Secret\nconfigured with the OIDC provider.\n",
                    "secret": true
                },
                "oidcDisableUserinfo": {
                    "type": "boolean",
                    "description": "`(bool: false)` - When set to `true`, Nomad will\nnot make a request to the identity provider to get OIDC `UserInfo`.\nYou may wish to set this if your identity provider doesn't send any\nadditional claims from the `UserInfo` endpoint.\n"
                },
                "oidcDiscoveryUrl": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The OIDC Discovery URL,\nwithout any .well-known component (base path).\n"
                },
                "oidcEnablePkce": {
                    "type": "boolean",
                    "description": "`(bool: false)` - When set to `true`, Nomad will include\n[PKCE][] verification in the auth flow. Even with PKCE enabled in Nomad,\nyou may still need to enable it in your OIDC provider.\n"
                },
                "oidcScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - List of OIDC scopes.\n"
                },
                "signingAlgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - A list of supported signing\nalgorithms.\n"
                },
                "verboseLogging": {
                    "type": "boolean",
                    "description": "Enable OIDC verbose logging on the Nomad server.\n"
                }
            },
            "type": "object"
        },
        "nomad:index/AclAuthMethodConfigOidcClientAssertion:AclAuthMethodConfigOidcClientAssertion": {
            "properties": {
                "audiences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: optional)` - Who processes the assertion.\nDefaults to the auth method's `oidc_discovery_url`.\n"
                },
                "extraHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: optional)` - Add to the JWT headers,\nalongside \"kid\" and \"type\". Setting the \"kid\" header here is not allowed;\nuse `private_key.key_id`.\n"
                },
                "keyAlgorithm": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` is the key's algorithm.\nIts default values are based on the `key_source`:\n- \"nomad\": \"RS256\"; this is from Nomad's keyring and must not be changed\n- \"private_key\": \"RS256\"; must be RS256, RS384, or RS512\n- \"client_secret\": \"HS256\"; must be HS256, HS384, or HS512\n"
                },
                "keySource": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Specifies where to get the private\nkey to sign the JWT.\nAvailable sources:\n- \"nomad\": Use current active key in Nomad's keyring\n- \"private_key\": Use key material in the `private_key` field\n- \"client_secret\": Use the `oidc_client_secret` as an HMAC key\n"
                },
                "privateKey": {
                    "$ref": "#/types/nomad:index/AclAuthMethodConfigOidcClientAssertionPrivateKey:AclAuthMethodConfigOidcClientAssertionPrivateKey",
                    "description": "`(OIDCClientAssertionKey: \u003coptional\u003e)` - External key\nto sign the JWT. `key_source` must be \"private_key\" to enable this.\n"
                }
            },
            "type": "object",
            "required": [
                "keySource"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "audiences",
                        "keyAlgorithm",
                        "keySource"
                    ]
                }
            }
        },
        "nomad:index/AclAuthMethodConfigOidcClientAssertionPrivateKey:AclAuthMethodConfigOidcClientAssertionPrivateKey": {
            "properties": {
                "keyId": {
                    "type": "string",
                    "description": "`(string: optional)` - Becomes the JWT's \"kid\" header.\nMutually exclusive with `pem_cert` and `pem_cert_file`.\nAllowed `key_id_header` values: \"kid\" (the default)\n"
                },
                "keyIdHeader": {
                    "type": "string",
                    "description": "`(string: optional)` - Which header the provider uses\nto find the public key to verify the signed JWT.\nThe default and allowed values depend on whether you set `key_id`,\n`pem_cert`, or `pem_cert_file`. You must set exactly one of those\noptions, so refer to them for their requirements.\n"
                },
                "pemCert": {
                    "type": "string",
                    "description": "`(string: optional)` - An x509 certificate, signed by the\nprivate key or a CA, in pem format. Nomad uses this certificate to\nderive an [x5t#S256][] (or [x5t][]) key_id.\nMutually exclusive with `pem_cert_file` and `key_id`.\nAllowed `key_id_header` values: \"x5t\", \"x5t#S256\" (default \"x5t#S256\")\n"
                },
                "pemCertFile": {
                    "type": "string",
                    "description": "`(string: optional)` - An absolute path to an x509\ncertificate on Nomad servers' disk, signed by the private key or a CA,\nin pem format.\nNomad uses this certificate to derive an [x5t#S256][] (or [x5t][])\nheader. Mutually exclusive with `pem_cert` and key_id.\nAllowed `key_id_header` values: \"x5t\", \"x5t#S256\" (default \"x5t#S256\")\n"
                },
                "pemKey": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - An RSA private key, in pem format.\nIt is used to sign the JWT. Mutually exclusive with `pem_key`.\n",
                    "secret": true
                },
                "pemKeyFile": {
                    "type": "string",
                    "description": "`(string: optional)` - An absolute path to a private key\non Nomad servers' disk, in pem format. It is used to sign the JWT.\nMutually exclusive with `pem_key_file`.\n"
                }
            },
            "type": "object"
        },
        "nomad:index/AclPolicyJobAcl:AclPolicyJobAcl": {
            "properties": {
                "group": {
                    "type": "string",
                    "description": "Group\n"
                },
                "jobId": {
                    "type": "string",
                    "description": "Job\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Namespace\n"
                },
                "task": {
                    "type": "string",
                    "description": "Task\n"
                }
            },
            "type": "object",
            "required": [
                "jobId"
            ]
        },
        "nomad:index/AclRolePolicy:AclRolePolicy": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A human-friendly name for this ACL Role.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "nomad:index/AclTokenRole:AclTokenRole": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of the ACL role to link.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \"\")` - A human-friendly name for this token.\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name"
                    ]
                }
            }
        },
        "nomad:index/CsiVolumeCapability:CsiVolumeCapability": {
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Defines whether a volume should be available concurrently. Possible values are:\n- `single-node-reader-only`\n- `single-node-writer`\n- `multi-node-reader-only`\n- `multi-node-single-writer`\n- `multi-node-multi-writer`\n"
                },
                "attachmentMode": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The storage API that will be used by the volume. Possible values are:\n- `block-device`\n- `file-system`\n"
                }
            },
            "type": "object",
            "required": [
                "accessMode",
                "attachmentMode"
            ]
        },
        "nomad:index/CsiVolumeMountOptions:CsiVolumeMountOptions": {
            "properties": {
                "fsType": {
                    "type": "string",
                    "description": "`(string: optional)` - The file system type.\n"
                },
                "mountFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`[]string: optional` - The flags passed to `mount`.\n"
                }
            },
            "type": "object"
        },
        "nomad:index/CsiVolumeRegistrationCapability:CsiVolumeRegistrationCapability": {
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Defines whether a volume should be available concurrently. Possible values are:\n- `single-node-reader-only`\n- `single-node-writer`\n- `multi-node-reader-only`\n- `multi-node-single-writer`\n- `multi-node-multi-writer`\n"
                },
                "attachmentMode": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The storage API that will be used by the volume. Possible values are:\n- `block-device`\n- `file-system`\n"
                }
            },
            "type": "object",
            "required": [
                "accessMode",
                "attachmentMode"
            ]
        },
        "nomad:index/CsiVolumeRegistrationMountOptions:CsiVolumeRegistrationMountOptions": {
            "properties": {
                "fsType": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The file system type.\n"
                },
                "mountFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - The flags passed to `mount`.\n"
                }
            },
            "type": "object"
        },
        "nomad:index/CsiVolumeRegistrationTopology:CsiVolumeRegistrationTopology": {
            "properties": {
                "segments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string)` - Define the attributes for the topology request.\n\nIn addition to the above arguments, the following attributes are exported and\ncan be referenced:\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "segments"
                    ]
                }
            }
        },
        "nomad:index/CsiVolumeRegistrationTopologyRequest:CsiVolumeRegistrationTopologyRequest": {
            "properties": {
                "required": {
                    "$ref": "#/types/nomad:index/CsiVolumeRegistrationTopologyRequestRequired:CsiVolumeRegistrationTopologyRequestRequired",
                    "description": "`(``Topology``: \u003coptional\u003e)` - Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "nomad:index/CsiVolumeRegistrationTopologyRequestRequired:CsiVolumeRegistrationTopologyRequestRequired": {
            "properties": {
                "topologies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/CsiVolumeRegistrationTopologyRequestRequiredTopology:CsiVolumeRegistrationTopologyRequestRequiredTopology"
                    },
                    "description": "Defines the location for the volume.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "topologies"
            ]
        },
        "nomad:index/CsiVolumeRegistrationTopologyRequestRequiredTopology:CsiVolumeRegistrationTopologyRequestRequiredTopology": {
            "properties": {
                "segments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Define attributes for the topology request.\n"
                }
            },
            "type": "object",
            "required": [
                "segments"
            ]
        },
        "nomad:index/CsiVolumeTopology:CsiVolumeTopology": {
            "properties": {
                "segments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string)` - Define the attributes for the topology request.\n\nIn addition to the above arguments, the following attributes are exported and\ncan be referenced:\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "segments"
                    ]
                }
            }
        },
        "nomad:index/CsiVolumeTopologyRequest:CsiVolumeTopologyRequest": {
            "properties": {
                "preferred": {
                    "$ref": "#/types/nomad:index/CsiVolumeTopologyRequestPreferred:CsiVolumeTopologyRequestPreferred",
                    "description": "`(``Topology``: \u003coptional\u003e)` - Preferred topologies indicate that the volume should be created in a location accessible from some of the listed topologies.\n",
                    "willReplaceOnChanges": true
                },
                "required": {
                    "$ref": "#/types/nomad:index/CsiVolumeTopologyRequestRequired:CsiVolumeTopologyRequestRequired",
                    "description": "`(``Topology``: \u003coptional\u003e)` - Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "nomad:index/CsiVolumeTopologyRequestPreferred:CsiVolumeTopologyRequestPreferred": {
            "properties": {
                "topologies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/CsiVolumeTopologyRequestPreferredTopology:CsiVolumeTopologyRequestPreferredTopology"
                    },
                    "description": "Defines the location for the volume.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "topologies"
            ]
        },
        "nomad:index/CsiVolumeTopologyRequestPreferredTopology:CsiVolumeTopologyRequestPreferredTopology": {
            "properties": {
                "segments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Define the attributes for the topology request.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "segments"
            ]
        },
        "nomad:index/CsiVolumeTopologyRequestRequired:CsiVolumeTopologyRequestRequired": {
            "properties": {
                "topologies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/CsiVolumeTopologyRequestRequiredTopology:CsiVolumeTopologyRequestRequiredTopology"
                    },
                    "description": "Defines the location for the volume.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "topologies"
            ]
        },
        "nomad:index/CsiVolumeTopologyRequestRequiredTopology:CsiVolumeTopologyRequestRequiredTopology": {
            "properties": {
                "segments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Define the attributes for the topology request.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "segments"
            ]
        },
        "nomad:index/DynamicHostVolumeCapability:DynamicHostVolumeCapability": {
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "`(string)` - How the volume can be mounted by\nallocations. Refer to the [`access_mode`][] documentation for details.\n"
                },
                "attachmentMode": {
                    "type": "string",
                    "description": "`(string)` - The storage API that will be used by the\nvolume. Refer to the [`attachment_mode`][] documentation.\n"
                }
            },
            "type": "object",
            "required": [
                "accessMode",
                "attachmentMode"
            ]
        },
        "nomad:index/DynamicHostVolumeConstraint:DynamicHostVolumeConstraint": {
            "properties": {
                "attribute": {
                    "type": "string",
                    "description": "`(string)` - The [node attribute][] to check for the constraint.\n"
                },
                "operator": {
                    "type": "string",
                    "description": "`(string)`- The operator to use in the comparison.\n"
                },
                "value": {
                    "type": "string",
                    "description": "`(string)` - The value of the attribute to compare against.\n"
                }
            },
            "type": "object",
            "required": [
                "attribute"
            ]
        },
        "nomad:index/DynamicHostVolumeRegistrationCapability:DynamicHostVolumeRegistrationCapability": {
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "`(string)` - How the volume can be mounted by\nallocations. Refer to the [`access_mode`][] documentation for details.\n"
                },
                "attachmentMode": {
                    "type": "string",
                    "description": "`(string)` - The storage API that will be used by the\nvolume. Refer to the [`attachment_mode`][] documentation.\n"
                }
            },
            "type": "object",
            "required": [
                "accessMode",
                "attachmentMode"
            ]
        },
        "nomad:index/DynamicHostVolumeRegistrationConstraint:DynamicHostVolumeRegistrationConstraint": {
            "properties": {
                "attribute": {
                    "type": "string",
                    "description": "An attribute to check to constrain volume placement\n"
                },
                "operator": {
                    "type": "string",
                    "description": "The operator to use for comparison\n"
                },
                "value": {
                    "type": "string",
                    "description": "The requested value of the attribute\n"
                }
            },
            "type": "object",
            "required": [
                "attribute"
            ]
        },
        "nomad:index/ExternalVolumeCapability:ExternalVolumeCapability": {
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Defines whether a volume should be available concurrently. Possible values are:\n- `single-node-reader-only`\n- `single-node-writer`\n- `multi-node-reader-only`\n- `multi-node-single-writer`\n- `multi-node-multi-writer`\n"
                },
                "attachmentMode": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The storage API that will be used by the volume. Possible values are:\n- `block-device`\n- `file-system`\n"
                }
            },
            "type": "object",
            "required": [
                "accessMode",
                "attachmentMode"
            ]
        },
        "nomad:index/ExternalVolumeMountOptions:ExternalVolumeMountOptions": {
            "properties": {
                "fsType": {
                    "type": "string",
                    "description": "`(string: optional)` - The file system type.\n"
                },
                "mountFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`[]string: optional` - The flags passed to `mount`.\n"
                }
            },
            "type": "object"
        },
        "nomad:index/ExternalVolumeTopology:ExternalVolumeTopology": {
            "properties": {
                "segments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string)` - Define the attributes for the topology request.\n\nIn addition to the above arguments, the following attributes are exported and\ncan be referenced:\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "segments"
                    ]
                }
            }
        },
        "nomad:index/ExternalVolumeTopologyRequest:ExternalVolumeTopologyRequest": {
            "properties": {
                "preferred": {
                    "$ref": "#/types/nomad:index/ExternalVolumeTopologyRequestPreferred:ExternalVolumeTopologyRequestPreferred",
                    "description": "`(``Topology``: \u003coptional\u003e)` - Preferred topologies indicate that the volume should be created in a location accessible from some of the listed topologies.\n",
                    "willReplaceOnChanges": true
                },
                "required": {
                    "$ref": "#/types/nomad:index/ExternalVolumeTopologyRequestRequired:ExternalVolumeTopologyRequestRequired",
                    "description": "`(``Topology``: \u003coptional\u003e)` - Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "nomad:index/ExternalVolumeTopologyRequestPreferred:ExternalVolumeTopologyRequestPreferred": {
            "properties": {
                "topologies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/ExternalVolumeTopologyRequestPreferredTopology:ExternalVolumeTopologyRequestPreferredTopology"
                    },
                    "description": "Defines the location for the volume.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "topologies"
            ]
        },
        "nomad:index/ExternalVolumeTopologyRequestPreferredTopology:ExternalVolumeTopologyRequestPreferredTopology": {
            "properties": {
                "segments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Define the attributes for the topology request.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "segments"
            ]
        },
        "nomad:index/ExternalVolumeTopologyRequestRequired:ExternalVolumeTopologyRequestRequired": {
            "properties": {
                "topologies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/ExternalVolumeTopologyRequestRequiredTopology:ExternalVolumeTopologyRequestRequiredTopology"
                    },
                    "description": "Defines the location for the volume.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "topologies"
            ]
        },
        "nomad:index/ExternalVolumeTopologyRequestRequiredTopology:ExternalVolumeTopologyRequestRequiredTopology": {
            "properties": {
                "segments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Define the attributes for the topology request.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "segments"
            ]
        },
        "nomad:index/JobHcl2:JobHcl2": {
            "properties": {
                "allowFs": {
                    "type": "boolean",
                    "description": "`(boolean: false)` - Set this to `true` to be able to use\nHCL2 filesystem functions\n"
                },
                "vars": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Additional variables to use when templating the job with HCL2\n"
                }
            },
            "type": "object"
        },
        "nomad:index/JobTaskGroup:JobTaskGroup": {
            "properties": {
                "count": {
                    "type": "integer"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "tasks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/JobTaskGroupTask:JobTaskGroupTask"
                    }
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/JobTaskGroupVolume:JobTaskGroupVolume"
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "count",
                        "meta",
                        "name",
                        "tasks",
                        "volumes"
                    ]
                }
            }
        },
        "nomad:index/JobTaskGroupTask:JobTaskGroupTask": {
            "properties": {
                "driver": {
                    "type": "string"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "volumeMounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/JobTaskGroupTaskVolumeMount:JobTaskGroupTaskVolumeMount"
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "driver",
                        "meta",
                        "name",
                        "volumeMounts"
                    ]
                }
            }
        },
        "nomad:index/JobTaskGroupTaskVolumeMount:JobTaskGroupTaskVolumeMount": {
            "properties": {
                "destination": {
                    "type": "string"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "volume": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "destination",
                        "readOnly",
                        "volume"
                    ]
                }
            }
        },
        "nomad:index/JobTaskGroupVolume:JobTaskGroupVolume": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "source": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "readOnly",
                        "source",
                        "type"
                    ]
                }
            }
        },
        "nomad:index/NamespaceCapabilities:NamespaceCapabilities": {
            "properties": {
                "disabledTaskDrivers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - Task drivers disabled for the namespace.\n"
                },
                "enabledTaskDrivers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - Task drivers enabled for the namespace.\n"
                }
            },
            "type": "object"
        },
        "nomad:index/NamespaceNodePoolConfig:NamespaceNodePoolConfig": {
            "properties": {
                "alloweds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - The list of node pools that are allowed to be used in this namespace.\n"
                },
                "default": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The default node pool for jobs that don't define one.\n"
                },
                "denieds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - The list of node pools that are not allowed to be used in this namespace.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "default"
                    ]
                }
            }
        },
        "nomad:index/NodePoolSchedulerConfig:NodePoolSchedulerConfig": {
            "properties": {
                "memoryOversubscription": {
                    "type": "string",
                    "description": "`(string)` - Whether or not memory\noversubscription is enabled in the node pool. Possible values are\n`\"enabled\"` or `\"disabled\"`. If not defined the global cluster\nconfiguration is used.\n\n\u003e This option differs from Nomad, where it's represented as a boolean, to\nallow distinguishing between memory oversubscription being disabled in the\nnode pool and this property not being set.\n"
                },
                "schedulerAlgorithm": {
                    "type": "string",
                    "description": "`(string)` - The scheduler algorithm used in the node\npool. Possible values are `binpack` or `spread`. If not defined the global\ncluster configuration is used.\n"
                }
            },
            "type": "object"
        },
        "nomad:index/ProviderHeader:ProviderHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The header name\n"
                },
                "value": {
                    "type": "string",
                    "description": "The header value\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "nomad:index/QuoteSpecificationLimit:QuoteSpecificationLimit": {
            "properties": {
                "region": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The region these limits should apply to.\n"
                },
                "regionLimit": {
                    "$ref": "#/types/nomad:index/QuoteSpecificationLimitRegionLimit:QuoteSpecificationLimitRegionLimit",
                    "description": "`(block: \u003crequired\u003e)` - The limits to enforce. This block\nmay only be specified once in the `limits` block. Its structure is\ndocumented below.\n"
                }
            },
            "type": "object",
            "required": [
                "region",
                "regionLimit"
            ]
        },
        "nomad:index/QuoteSpecificationLimitRegionLimit:QuoteSpecificationLimitRegionLimit": {
            "properties": {
                "cpu": {
                    "type": "integer",
                    "description": "`(int: 0)` - The amount of CPU to limit allocations to. A value of zero\nis treated as unlimited, and a negative value is treated as fully disallowed.\n"
                },
                "memoryMb": {
                    "type": "integer",
                    "description": "`(int: 0)` - The amount of memory (in megabytes) to limit\nallocations to. A value of zero is treated as unlimited, and a negative value\nis treated as fully disallowed.\n"
                }
            },
            "type": "object"
        },
        "nomad:index/VolumeCapability:VolumeCapability": {
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Defines whether a volume should be available concurrently. Possible values are:\n- `single-node-reader-only`\n- `single-node-writer`\n- `multi-node-reader-only`\n- `multi-node-single-writer`\n- `multi-node-multi-writer`\n"
                },
                "attachmentMode": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The storage API that will be used by the volume. Possible values are:\n- `block-device`\n- `file-system`\n"
                }
            },
            "type": "object",
            "required": [
                "accessMode",
                "attachmentMode"
            ]
        },
        "nomad:index/VolumeMountOptions:VolumeMountOptions": {
            "properties": {
                "fsType": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The file system type.\n"
                },
                "mountFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string: \u003coptional\u003e)` - The flags passed to `mount`.\n"
                }
            },
            "type": "object"
        },
        "nomad:index/VolumeTopology:VolumeTopology": {
            "properties": {
                "segments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string)` - Define the attributes for the topology request.\n\nIn addition to the above arguments, the following attributes are exported and\ncan be referenced:\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "segments"
                    ]
                }
            }
        },
        "nomad:index/VolumeTopologyRequest:VolumeTopologyRequest": {
            "properties": {
                "required": {
                    "$ref": "#/types/nomad:index/VolumeTopologyRequestRequired:VolumeTopologyRequestRequired",
                    "description": "`(``Topology``: \u003coptional\u003e)` - Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "nomad:index/VolumeTopologyRequestRequired:VolumeTopologyRequestRequired": {
            "properties": {
                "topologies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/VolumeTopologyRequestRequiredTopology:VolumeTopologyRequestRequiredTopology"
                    },
                    "description": "Defines the location for the volume.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "topologies"
            ]
        },
        "nomad:index/VolumeTopologyRequestRequiredTopology:VolumeTopologyRequestRequiredTopology": {
            "properties": {
                "segments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Define attributes for the topology request.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "segments"
            ]
        },
        "nomad:index/getAclPoliciesPolicy:getAclPoliciesPolicy": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "`(string)` - the description of the ACL Policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string)` - the name of the ACL Policy.\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getAclRolePolicy:getAclRolePolicy": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "`(string)` - Unique name of the ACL role.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getAclRolesAclRole:getAclRolesAclRole": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "`(string)` - The description of the ACL Role.\n"
                },
                "id": {
                    "type": "string",
                    "description": "`(string)` - The ACL Role unique identifier.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string)` - Unique name of the ACL role.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/getAclRolesAclRolePolicy:getAclRolesAclRolePolicy"
                    },
                    "description": "`(set)` - The policies applied to the role.\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "id",
                "name",
                "policies"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getAclRolesAclRolePolicy:getAclRolesAclRolePolicy": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "`(string)` - Unique name of the ACL role.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getAclTokenRole:getAclTokenRole": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of the ACL role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string)` Non-sensitive identifier for this token.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getAclTokensAclToken:getAclTokensAclToken": {
            "properties": {
                "accessorId": {
                    "type": "string",
                    "description": "`(TypeString)` Non-sensitive identifier for the token.\n"
                },
                "createTime": {
                    "type": "string",
                    "description": "`(string)` Date and time the token was created at.\n"
                },
                "expirationTime": {
                    "type": "string",
                    "description": "`(string)` - The timestamp after which the token is\nconsidered expired and eligible for destruction.\n"
                },
                "global": {
                    "type": "boolean",
                    "description": "`(bool)` Whether the token is replicated to all regions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(TypeString)` The name of the token.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`(list of strings)` The list of policies attached to the token.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/getAclTokensAclTokenRole:getAclTokensAclTokenRole"
                    },
                    "description": "`(set: [])` - The list of roles attached to the token. Each entry has\n`name` and `id` attributes.\n"
                },
                "type": {
                    "type": "string",
                    "description": "`(TypeString)` The type of the token.\n"
                }
            },
            "type": "object",
            "required": [
                "accessorId",
                "createTime",
                "expirationTime",
                "global",
                "name",
                "policies",
                "roles",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getAclTokensAclTokenRole:getAclTokensAclTokenRole": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of the ACL role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(TypeString)` The name of the token.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getAllocationsAllocation:getAllocationsAllocation": {
            "properties": {
                "clientStatus": {
                    "type": "string",
                    "description": "`(string)` - The current client status of the allocation.\n"
                },
                "createIndex": {
                    "type": "integer",
                    "description": "`(int)` - The Raft index in which the allocation was created.\n"
                },
                "createTime": {
                    "type": "integer",
                    "description": "`(int)` - The timestamp of when the allocation was created.\n"
                },
                "desiredStatus": {
                    "type": "string",
                    "description": "`(string)` - The current desired status of the allocation.\n"
                },
                "evalId": {
                    "type": "string",
                    "description": "`(string)` - The ID of the evaluation that generated the allocation.\n"
                },
                "followupEvalId": {
                    "type": "string",
                    "description": "`(string)` - The ID of the evaluation that succeeds the allocation evaluation.\n"
                },
                "id": {
                    "type": "string",
                    "description": "`(string)` - The ID of the allocation.\n"
                },
                "jobId": {
                    "type": "string",
                    "description": "`(string)` - The ID of the job related to the allocation.\n"
                },
                "jobType": {
                    "type": "string",
                    "description": "`(string)` - The type of the job related to the allocation.\n"
                },
                "jobVersion": {
                    "type": "integer",
                    "description": "`(int)` - The version of the job that generated the allocation.\n"
                },
                "modifyIndex": {
                    "type": "integer",
                    "description": "`(int)` - The Raft index in which the allocation was last modified.\n"
                },
                "modifyTime": {
                    "type": "integer",
                    "description": "`(int)` - The timestamp of when the allocation was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string)` - The name of the allocation.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Specifies the namespace to search for\nallocations in.\n"
                },
                "nextAllocation": {
                    "type": "string",
                    "description": "`(string)` - The ID of the allocation that succeeds the allocation.\n"
                },
                "nodeId": {
                    "type": "string",
                    "description": "`(string)` - The ID of the node to which the allocation was scheduled.\n"
                },
                "nodeName": {
                    "type": "string",
                    "description": "`(string)` - The ID of the node to which the allocation was scheduled.\n"
                },
                "preemptedByAllocation": {
                    "type": "string",
                    "description": "`(string)` - The ID of the allocation that preempted the allocation.\n"
                },
                "taskGroup": {
                    "type": "string",
                    "description": "`(string)` - The job task group related to the allocation.\n"
                }
            },
            "type": "object",
            "required": [
                "clientStatus",
                "createIndex",
                "createTime",
                "desiredStatus",
                "evalId",
                "followupEvalId",
                "id",
                "jobId",
                "jobType",
                "jobVersion",
                "modifyIndex",
                "modifyTime",
                "name",
                "namespace",
                "nextAllocation",
                "nodeId",
                "nodeName",
                "preemptedByAllocation",
                "taskGroup"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getDynamicHostVolumeCapability:getDynamicHostVolumeCapability": {
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "`(string)` - How the volume can be mounted by\nallocations. Refer to the [`access_mode`][] documentation for details.\n"
                },
                "attachmentMode": {
                    "type": "string",
                    "description": "`(string)` - The storage API that will be used by the\nvolume. Refer to the [`attachment_mode`][] documentation.\n"
                }
            },
            "type": "object",
            "required": [
                "accessMode",
                "attachmentMode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getDynamicHostVolumeConstraint:getDynamicHostVolumeConstraint": {
            "properties": {
                "attribute": {
                    "type": "string",
                    "description": "`(string)` - The [node attribute][] to check for the constraint.\n"
                },
                "operator": {
                    "type": "string",
                    "description": "`(string)`- The operator to use in the comparison.\n"
                },
                "value": {
                    "type": "string",
                    "description": "`(string)` - The value of the attribute to compare against.\n"
                }
            },
            "type": "object",
            "required": [
                "attribute",
                "operator",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getJobConstraint:getJobConstraint": {
            "properties": {
                "ltarget": {
                    "type": "string",
                    "description": "`(string)` Attribute being constrained.\n"
                },
                "operand": {
                    "type": "string",
                    "description": "`(string)` Operator used to compare the attribute to the constraint.\n"
                },
                "rtarget": {
                    "type": "string",
                    "description": "`(string)` Constraint value.\n"
                }
            },
            "type": "object",
            "required": [
                "ltarget",
                "operand",
                "rtarget"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getJobPeriodicConfig:getJobPeriodicConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`(boolean)` If periodic scheduling is enabled for the specified job.\n"
                },
                "prohibitOverlap": {
                    "type": "boolean",
                    "description": "`(boolean)`  If the specified job should wait until previous instances of the job have completed.\n"
                },
                "spec": {
                    "type": "string",
                    "description": "`(string)`\n"
                },
                "specType": {
                    "type": "string",
                    "description": "`(string)`\n"
                },
                "timezone": {
                    "type": "string",
                    "description": "`(string)` Time zone to evaluate the next launch interval against.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "prohibitOverlap",
                "spec",
                "specType",
                "timezone"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getJobTaskGroup:getJobTaskGroup": {
            "properties": {
                "count": {
                    "type": "integer"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "`(string)` Name of the job.\n"
                },
                "tasks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/getJobTaskGroupTask:getJobTaskGroupTask"
                    }
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/getJobTaskGroupVolume:getJobTaskGroupVolume"
                    }
                }
            },
            "type": "object",
            "required": [
                "count",
                "meta",
                "name",
                "tasks",
                "volumes"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getJobTaskGroupTask:getJobTaskGroupTask": {
            "properties": {
                "driver": {
                    "type": "string"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "`(string)` Name of the job.\n"
                },
                "volumeMounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/getJobTaskGroupTaskVolumeMount:getJobTaskGroupTaskVolumeMount"
                    }
                }
            },
            "type": "object",
            "required": [
                "driver",
                "meta",
                "name",
                "volumeMounts"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getJobTaskGroupTaskVolumeMount:getJobTaskGroupTaskVolumeMount": {
            "properties": {
                "destination": {
                    "type": "string"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "volume": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "destination",
                "readOnly",
                "volume"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getJobTaskGroupVolume:getJobTaskGroupVolume": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "`(string)` Name of the job.\n"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "source": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "`(string)` Scheduler type used during job creation.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "readOnly",
                "source",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getJwksKey:getJwksKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "`(string)` - JWK field `alg`\n"
                },
                "exponent": {
                    "type": "string",
                    "description": "`(string)` - JWK field `e`\n"
                },
                "keyId": {
                    "type": "string",
                    "description": "`(string)` - JWK field `kid`\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "`(string)` - JWK field `kty`\n"
                },
                "keyUse": {
                    "type": "string",
                    "description": "`(string)` - JWK field `use`\n"
                },
                "modulus": {
                    "type": "string",
                    "description": "`(string)` - JWK field `n`\n"
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "exponent",
                "keyId",
                "keyType",
                "keyUse",
                "modulus"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getNamespaceCapability:getNamespaceCapability": {
            "properties": {
                "disabledTaskDrivers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string)` - Task drivers disabled for the namespace.\n"
                },
                "enabledTaskDrivers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`([]string)` - Task drivers enabled for the namespace.\n"
                }
            },
            "type": "object"
        },
        "nomad:index/getNamespaceNodePoolConfig:getNamespaceNodePoolConfig": {
            "properties": {
                "alloweds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "default": {
                    "type": "string"
                },
                "denieds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "alloweds",
                "default",
                "denieds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getNodePoolSchedulerConfig:getNodePoolSchedulerConfig": {
            "properties": {
                "memoryOversubscription": {
                    "type": "string",
                    "description": "`(string)` - Whether or not memory\noversubscription is enabled in the node pool. If empty or not defined the\nglobal cluster configuration is used.\n"
                },
                "schedulerAlgorithm": {
                    "type": "string",
                    "description": "`(string)` - The scheduler algorithm used in the node\npool. If empty or not defined the global cluster configuration is used.\n"
                }
            },
            "type": "object",
            "required": [
                "memoryOversubscription",
                "schedulerAlgorithm"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getNodePoolsNodePool:getNodePoolsNodePool": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "`(string)` - The description of the node pool.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string)` - Arbitrary KV metadata associated with the\nnode pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string)` - The name of the node pool.\n"
                },
                "schedulerConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/getNodePoolsNodePoolSchedulerConfig:getNodePoolsNodePoolSchedulerConfig"
                    },
                    "description": "`(block)` - Scheduler configuration for the node pool.\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "meta",
                "name",
                "schedulerConfigs"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getNodePoolsNodePoolSchedulerConfig:getNodePoolsNodePoolSchedulerConfig": {
            "properties": {
                "memoryOversubscription": {
                    "type": "string",
                    "description": "`(string)` - Whether or not memory\noversubscription is enabled in the node pool. If empty or not defined the\nglobal cluster configuration is used.\n"
                },
                "schedulerAlgorithm": {
                    "type": "string",
                    "description": "`(string)` - The scheduler algorithm used in the node\npool. If empty or not defined the global cluster configuration is used.\n"
                }
            },
            "type": "object",
            "required": [
                "memoryOversubscription",
                "schedulerAlgorithm"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getPluginNode:getPluginNode": {
            "properties": {
                "healthy": {
                    "type": "boolean"
                },
                "healthyDescription": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "healthy",
                "healthyDescription",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "nomad:index/getScalingPoliciesPolicy:getScalingPoliciesPolicy": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`(boolean)` - Whether or not the scaling policy is enabled.\n"
                },
                "id": {
                    "type": "string",
                    "description": "`(string)` - The scaling policy ID.\n"
                },
                "target": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string)` - The scaling policy target.\n"
                },
                "type": {
                    "type": "string",
                    "description": "`(string)` - An optional string to filter scaling policies based on policy type. If not provided, policies of all types are returned.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "id",
                "target",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the nomad package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "address": {
                "type": "string",
                "description": "URL of the root of the target Nomad agent."
            },
            "caFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "caPem": {
                "type": "string",
                "description": "PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "certFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate provided to the remote agent; requires use of key_file or key_pem."
            },
            "certPem": {
                "type": "string",
                "description": "PEM-encoded certificate provided to the remote agent; requires use of key_file or key_pem."
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/nomad:index/ProviderHeader:ProviderHeader"
                },
                "description": "The headers to send with each Nomad request.",
                "secret": true
            },
            "httpAuth": {
                "type": "string",
                "description": "HTTP basic auth configuration."
            },
            "ignoreEnvVars": {
                "type": "object",
                "additionalProperties": {
                    "type": "boolean"
                },
                "description": "A set of environment variables that are ignored by the provider when configuring the Nomad API client."
            },
            "keyFile": {
                "type": "string",
                "description": "A path to a PEM-encoded private key, required if cert_file or cert_pem is specified."
            },
            "keyPem": {
                "type": "string",
                "description": "PEM-encoded private key, required if cert_file or cert_pem is specified."
            },
            "region": {
                "type": "string",
                "description": "Region of the target Nomad agent."
            },
            "secretId": {
                "type": "string",
                "description": "ACL token secret for API requests."
            },
            "skipVerify": {
                "type": "boolean",
                "description": "Skip TLS verification on client side."
            }
        },
        "inputProperties": {
            "address": {
                "type": "string",
                "description": "URL of the root of the target Nomad agent."
            },
            "caFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "caPem": {
                "type": "string",
                "description": "PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "certFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate provided to the remote agent; requires use of key_file or key_pem."
            },
            "certPem": {
                "type": "string",
                "description": "PEM-encoded certificate provided to the remote agent; requires use of key_file or key_pem."
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/nomad:index/ProviderHeader:ProviderHeader"
                },
                "description": "The headers to send with each Nomad request.",
                "secret": true
            },
            "httpAuth": {
                "type": "string",
                "description": "HTTP basic auth configuration."
            },
            "ignoreEnvVars": {
                "type": "object",
                "additionalProperties": {
                    "type": "boolean"
                },
                "description": "A set of environment variables that are ignored by the provider when configuring the Nomad API client."
            },
            "keyFile": {
                "type": "string",
                "description": "A path to a PEM-encoded private key, required if cert_file or cert_pem is specified."
            },
            "keyPem": {
                "type": "string",
                "description": "PEM-encoded private key, required if cert_file or cert_pem is specified."
            },
            "region": {
                "type": "string",
                "description": "Region of the target Nomad agent."
            },
            "secretId": {
                "type": "string",
                "description": "ACL token secret for API requests."
            },
            "skipVerify": {
                "type": "boolean",
                "description": "Skip TLS verification on client side."
            }
        },
        "methods": {
            "terraformConfig": "pulumi:providers:nomad/terraformConfig"
        }
    },
    "resources": {
        "nomad:index/aclAuthMethod:AclAuthMethod": {
            "description": "Manages an ACL Auth Method in Nomad.\n\n## Example Usage\n\nCreating an ALC Auth Method:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst myNomadAclAuthMethod = new nomad.AclAuthMethod(\"my_nomad_acl_auth_method\", {\n    name: \"my-nomad-acl-auth-method\",\n    type: \"OIDC\",\n    tokenLocality: \"global\",\n    maxTokenTtl: \"10m0s\",\n    tokenNameFormat: `${auth_method_type}-${value.user}`,\n    \"default\": true,\n    config: {\n        oidcDiscoveryUrl: \"https://uk.auth0.com/\",\n        oidcClientId: \"someclientid\",\n        oidcClientSecret: \"someclientsecret-t\",\n        boundAudiences: [\"someclientid\"],\n        allowedRedirectUris: [\n            \"http://localhost:4649/oidc/callback\",\n            \"http://localhost:4646/ui/settings/tokens\",\n        ],\n        listClaimMappings: {\n            \"http://nomad.internal/roles\": \"roles\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nmy_nomad_acl_auth_method = nomad.AclAuthMethod(\"my_nomad_acl_auth_method\",\n    name=\"my-nomad-acl-auth-method\",\n    type=\"OIDC\",\n    token_locality=\"global\",\n    max_token_ttl=\"10m0s\",\n    token_name_format=\"${auth_method_type}-${value.user}\",\n    default=True,\n    config={\n        \"oidc_discovery_url\": \"https://uk.auth0.com/\",\n        \"oidc_client_id\": \"someclientid\",\n        \"oidc_client_secret\": \"someclientsecret-t\",\n        \"bound_audiences\": [\"someclientid\"],\n        \"allowed_redirect_uris\": [\n            \"http://localhost:4649/oidc/callback\",\n            \"http://localhost:4646/ui/settings/tokens\",\n        ],\n        \"list_claim_mappings\": {\n            \"http://nomad.internal/roles\": \"roles\",\n        },\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myNomadAclAuthMethod = new Nomad.AclAuthMethod(\"my_nomad_acl_auth_method\", new()\n    {\n        Name = \"my-nomad-acl-auth-method\",\n        Type = \"OIDC\",\n        TokenLocality = \"global\",\n        MaxTokenTtl = \"10m0s\",\n        TokenNameFormat = \"${auth_method_type}-${value.user}\",\n        Default = true,\n        Config = new Nomad.Inputs.AclAuthMethodConfigArgs\n        {\n            OidcDiscoveryUrl = \"https://uk.auth0.com/\",\n            OidcClientId = \"someclientid\",\n            OidcClientSecret = \"someclientsecret-t\",\n            BoundAudiences = new[]\n            {\n                \"someclientid\",\n            },\n            AllowedRedirectUris = new[]\n            {\n                \"http://localhost:4649/oidc/callback\",\n                \"http://localhost:4646/ui/settings/tokens\",\n            },\n            ListClaimMappings = \n            {\n                { \"http://nomad.internal/roles\", \"roles\" },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewAclAuthMethod(ctx, \"my_nomad_acl_auth_method\", \u0026nomad.AclAuthMethodArgs{\n\t\t\tName:            pulumi.String(\"my-nomad-acl-auth-method\"),\n\t\t\tType:            pulumi.String(\"OIDC\"),\n\t\t\tTokenLocality:   pulumi.String(\"global\"),\n\t\t\tMaxTokenTtl:     pulumi.String(\"10m0s\"),\n\t\t\tTokenNameFormat: pulumi.Sprintf(\"${auth_method_type}-${value.user}\"),\n\t\t\tDefault:         pulumi.Bool(true),\n\t\t\tConfig: \u0026nomad.AclAuthMethodConfigArgs{\n\t\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://uk.auth0.com/\"),\n\t\t\t\tOidcClientId:     pulumi.String(\"someclientid\"),\n\t\t\t\tOidcClientSecret: pulumi.String(\"someclientsecret-t\"),\n\t\t\t\tBoundAudiences: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"someclientid\"),\n\t\t\t\t},\n\t\t\t\tAllowedRedirectUris: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"http://localhost:4649/oidc/callback\"),\n\t\t\t\t\tpulumi.String(\"http://localhost:4646/ui/settings/tokens\"),\n\t\t\t\t},\n\t\t\t\tListClaimMappings: pulumi.StringMap{\n\t\t\t\t\t\"http://nomad.internal/roles\": pulumi.String(\"roles\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.AclAuthMethod;\nimport com.pulumi.nomad.AclAuthMethodArgs;\nimport com.pulumi.nomad.inputs.AclAuthMethodConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myNomadAclAuthMethod = new AclAuthMethod(\"myNomadAclAuthMethod\", AclAuthMethodArgs.builder()\n            .name(\"my-nomad-acl-auth-method\")\n            .type(\"OIDC\")\n            .tokenLocality(\"global\")\n            .maxTokenTtl(\"10m0s\")\n            .tokenNameFormat(\"${auth_method_type}-${value.user}\")\n            .default_(true)\n            .config(AclAuthMethodConfigArgs.builder()\n                .oidcDiscoveryUrl(\"https://uk.auth0.com/\")\n                .oidcClientId(\"someclientid\")\n                .oidcClientSecret(\"someclientsecret-t\")\n                .boundAudiences(\"someclientid\")\n                .allowedRedirectUris(                \n                    \"http://localhost:4649/oidc/callback\",\n                    \"http://localhost:4646/ui/settings/tokens\")\n                .listClaimMappings(Map.of(\"http://nomad.internal/roles\", \"roles\"))\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myNomadAclAuthMethod:\n    type: nomad:AclAuthMethod\n    name: my_nomad_acl_auth_method\n    properties:\n      name: my-nomad-acl-auth-method\n      type: OIDC\n      tokenLocality: global\n      maxTokenTtl: 10m0s\n      tokenNameFormat: $${auth_method_type}-$${value.user}\n      default: true\n      config:\n        oidcDiscoveryUrl: https://uk.auth0.com/\n        oidcClientId: someclientid\n        oidcClientSecret: someclientsecret-t\n        boundAudiences:\n          - someclientid\n        allowedRedirectUris:\n          - http://localhost:4649/oidc/callback\n          - http://localhost:4646/ui/settings/tokens\n        listClaimMappings:\n          http://nomad.internal/roles: roles\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "config": {
                    "$ref": "#/types/nomad:index/AclAuthMethodConfig:AclAuthMethodConfig",
                    "description": "`(block: \u003crequired\u003e)` - Configuration specific to the auth method\nprovider.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "`(bool: false)` - Defines whether this ACL Auth Method is to be set\nas default.\n"
                },
                "maxTokenTtl": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Defines the maximum life of a token\ncreated by this method and is specified as a time duration such as \"15h\".\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The identifier of the ACL Auth Method.\n"
                },
                "tokenLocality": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Defines whether the ACL Auth Method\ncreates a local or global token when performing SSO login. This field must be\nset to either `local` or `global`.\n"
                },
                "tokenNameFormat": {
                    "type": "string",
                    "description": "`(string: \"${auth_method_type}-${auth_method_name}\")` -\nDefines the token name format for the generated tokens This can be lightly\ntemplated using HIL '${foo}' syntax.\n"
                },
                "type": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - ACL Auth Method SSO workflow type. Valid values,\nare `OIDC` and `JWT`.\n"
                }
            },
            "required": [
                "config",
                "maxTokenTtl",
                "name",
                "tokenLocality",
                "type"
            ],
            "inputProperties": {
                "config": {
                    "$ref": "#/types/nomad:index/AclAuthMethodConfig:AclAuthMethodConfig",
                    "description": "`(block: \u003crequired\u003e)` - Configuration specific to the auth method\nprovider.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "`(bool: false)` - Defines whether this ACL Auth Method is to be set\nas default.\n"
                },
                "maxTokenTtl": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Defines the maximum life of a token\ncreated by this method and is specified as a time duration such as \"15h\".\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The identifier of the ACL Auth Method.\n"
                },
                "tokenLocality": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Defines whether the ACL Auth Method\ncreates a local or global token when performing SSO login. This field must be\nset to either `local` or `global`.\n"
                },
                "tokenNameFormat": {
                    "type": "string",
                    "description": "`(string: \"${auth_method_type}-${auth_method_name}\")` -\nDefines the token name format for the generated tokens This can be lightly\ntemplated using HIL '${foo}' syntax.\n"
                },
                "type": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - ACL Auth Method SSO workflow type. Valid values,\nare `OIDC` and `JWT`.\n"
                }
            },
            "requiredInputs": [
                "config",
                "maxTokenTtl",
                "tokenLocality",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclAuthMethod resources.\n",
                "properties": {
                    "config": {
                        "$ref": "#/types/nomad:index/AclAuthMethodConfig:AclAuthMethodConfig",
                        "description": "`(block: \u003crequired\u003e)` - Configuration specific to the auth method\nprovider.\n"
                    },
                    "default": {
                        "type": "boolean",
                        "description": "`(bool: false)` - Defines whether this ACL Auth Method is to be set\nas default.\n"
                    },
                    "maxTokenTtl": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - Defines the maximum life of a token\ncreated by this method and is specified as a time duration such as \"15h\".\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The identifier of the ACL Auth Method.\n"
                    },
                    "tokenLocality": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - Defines whether the ACL Auth Method\ncreates a local or global token when performing SSO login. This field must be\nset to either `local` or `global`.\n"
                    },
                    "tokenNameFormat": {
                        "type": "string",
                        "description": "`(string: \"${auth_method_type}-${auth_method_name}\")` -\nDefines the token name format for the generated tokens This can be lightly\ntemplated using HIL '${foo}' syntax.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - ACL Auth Method SSO workflow type. Valid values,\nare `OIDC` and `JWT`.\n"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/aclBindingRule:AclBindingRule": {
            "properties": {
                "authMethod": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Name of the auth method for which this\nrule applies to.\n"
                },
                "bindName": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Target of the binding. If `bind_type` is\n`role` or `policy` then `bind_name` is required. If `bind_type` is\n`management` than `bind_name` must not be defined.\n"
                },
                "bindType": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Adjusts how this binding rule is applied\nat login time. Valid values are `role`, `policy`, and `management`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - Description for this ACL binding rule.\n"
                },
                "selector": {
                    "type": "string",
                    "description": "`(string: \"\")` - A boolean expression that matches against verified\nidentity attributes returned from the auth method during login.\n"
                }
            },
            "required": [
                "authMethod",
                "bindType"
            ],
            "inputProperties": {
                "authMethod": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Name of the auth method for which this\nrule applies to.\n"
                },
                "bindName": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Target of the binding. If `bind_type` is\n`role` or `policy` then `bind_name` is required. If `bind_type` is\n`management` than `bind_name` must not be defined.\n"
                },
                "bindType": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Adjusts how this binding rule is applied\nat login time. Valid values are `role`, `policy`, and `management`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - Description for this ACL binding rule.\n"
                },
                "selector": {
                    "type": "string",
                    "description": "`(string: \"\")` - A boolean expression that matches against verified\nidentity attributes returned from the auth method during login.\n"
                }
            },
            "requiredInputs": [
                "authMethod",
                "bindType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclBindingRule resources.\n",
                "properties": {
                    "authMethod": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - Name of the auth method for which this\nrule applies to.\n"
                    },
                    "bindName": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Target of the binding. If `bind_type` is\n`role` or `policy` then `bind_name` is required. If `bind_type` is\n`management` than `bind_name` must not be defined.\n"
                    },
                    "bindType": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - Adjusts how this binding rule is applied\nat login time. Valid values are `role`, `policy`, and `management`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "`(string: \"\")` - Description for this ACL binding rule.\n"
                    },
                    "selector": {
                        "type": "string",
                        "description": "`(string: \"\")` - A boolean expression that matches against verified\nidentity attributes returned from the auth method during login.\n"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/aclPolicy:AclPolicy": {
            "description": "Manages an ACL policy registered in Nomad.\n\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - A description of the policy.\n"
                },
                "jobAcl": {
                    "$ref": "#/types/nomad:index/AclPolicyJobAcl:AclPolicyJobAcl",
                    "description": "`(``JobACL``: \u003coptional\u003e)` - Options for assigning the\nACL rules to a job, group, or task.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A unique name for the policy.\n"
                },
                "rulesHcl": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The contents of the policy to register,\nas HCL or JSON.\n"
                }
            },
            "required": [
                "name",
                "rulesHcl"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - A description of the policy.\n"
                },
                "jobAcl": {
                    "$ref": "#/types/nomad:index/AclPolicyJobAcl:AclPolicyJobAcl",
                    "description": "`(``JobACL``: \u003coptional\u003e)` - Options for assigning the\nACL rules to a job, group, or task.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A unique name for the policy.\n",
                    "willReplaceOnChanges": true
                },
                "rulesHcl": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The contents of the policy to register,\nas HCL or JSON.\n"
                }
            },
            "requiredInputs": [
                "rulesHcl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclPolicy resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "`(string: \"\")` - A description of the policy.\n"
                    },
                    "jobAcl": {
                        "$ref": "#/types/nomad:index/AclPolicyJobAcl:AclPolicyJobAcl",
                        "description": "`(``JobACL``: \u003coptional\u003e)` - Options for assigning the\nACL rules to a job, group, or task.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - A unique name for the policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "rulesHcl": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The contents of the policy to register,\nas HCL or JSON.\n"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/aclRole:AclRole": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - A description of the ACL Role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A human-friendly name for this ACL Role.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/AclRolePolicy:AclRolePolicy"
                    },
                    "description": "`(set: \u003crequired\u003e)` - A set of policy names to associate with this\nACL Role. It may be used multiple times.\n"
                }
            },
            "required": [
                "name",
                "policies"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - A description of the ACL Role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A human-friendly name for this ACL Role.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/AclRolePolicy:AclRolePolicy"
                    },
                    "description": "`(set: \u003crequired\u003e)` - A set of policy names to associate with this\nACL Role. It may be used multiple times.\n"
                }
            },
            "requiredInputs": [
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclRole resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "`(string: \"\")` - A description of the ACL Role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - A human-friendly name for this ACL Role.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/AclRolePolicy:AclRolePolicy"
                        },
                        "description": "`(set: \u003crequired\u003e)` - A set of policy names to associate with this\nACL Role. It may be used multiple times.\n"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/aclToken:AclToken": {
            "description": "## Example Usage\n\nCreating a token with limited policies:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst dakota = new nomad.AclToken(\"dakota\", {\n    name: \"Dakota\",\n    type: \"client\",\n    policies: [\n        \"dev\",\n        \"qa\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\ndakota = nomad.AclToken(\"dakota\",\n    name=\"Dakota\",\n    type=\"client\",\n    policies=[\n        \"dev\",\n        \"qa\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dakota = new Nomad.AclToken(\"dakota\", new()\n    {\n        Name = \"Dakota\",\n        Type = \"client\",\n        Policies = new[]\n        {\n            \"dev\",\n            \"qa\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewAclToken(ctx, \"dakota\", \u0026nomad.AclTokenArgs{\n\t\t\tName: pulumi.String(\"Dakota\"),\n\t\t\tType: pulumi.String(\"client\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"qa\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.AclToken;\nimport com.pulumi.nomad.AclTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dakota = new AclToken(\"dakota\", AclTokenArgs.builder()\n            .name(\"Dakota\")\n            .type(\"client\")\n            .policies(            \n                \"dev\",\n                \"qa\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dakota:\n    type: nomad:AclToken\n    properties:\n      name: Dakota\n      type: client\n      policies:\n        - dev\n        - qa\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nCreating a global token that will be replicated to all regions:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst dakota = new nomad.AclToken(\"dakota\", {\n    name: \"Dakota\",\n    type: \"client\",\n    policies: [\n        \"dev\",\n        \"qa\",\n    ],\n    global: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\ndakota = nomad.AclToken(\"dakota\",\n    name=\"Dakota\",\n    type=\"client\",\n    policies=[\n        \"dev\",\n        \"qa\",\n    ],\n    global_=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dakota = new Nomad.AclToken(\"dakota\", new()\n    {\n        Name = \"Dakota\",\n        Type = \"client\",\n        Policies = new[]\n        {\n            \"dev\",\n            \"qa\",\n        },\n        Global = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewAclToken(ctx, \"dakota\", \u0026nomad.AclTokenArgs{\n\t\t\tName: pulumi.String(\"Dakota\"),\n\t\t\tType: pulumi.String(\"client\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"qa\"),\n\t\t\t},\n\t\t\tGlobal: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.AclToken;\nimport com.pulumi.nomad.AclTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dakota = new AclToken(\"dakota\", AclTokenArgs.builder()\n            .name(\"Dakota\")\n            .type(\"client\")\n            .policies(            \n                \"dev\",\n                \"qa\")\n            .global(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dakota:\n    type: nomad:AclToken\n    properties:\n      name: Dakota\n      type: client\n      policies:\n        - dev\n        - qa\n      global: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nCreating a token with full access to the cluster:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst iman = new nomad.AclToken(\"iman\", {\n    name: \"Iman\",\n    type: \"management\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\niman = nomad.AclToken(\"iman\",\n    name=\"Iman\",\n    type=\"management\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var iman = new Nomad.AclToken(\"iman\", new()\n    {\n        Name = \"Iman\",\n        Type = \"management\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewAclToken(ctx, \"iman\", \u0026nomad.AclTokenArgs{\n\t\t\tName: pulumi.String(\"Iman\"),\n\t\t\tType: pulumi.String(\"management\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.AclToken;\nimport com.pulumi.nomad.AclTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var iman = new AclToken(\"iman\", AclTokenArgs.builder()\n            .name(\"Iman\")\n            .type(\"management\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  iman:\n    type: nomad:AclToken\n    properties:\n      name: Iman\n      type: management\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nAccessing the token:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst token = new nomad.AclToken(\"token\", {\n    type: \"client\",\n    policies: [\"dev\"],\n});\nexport const nomadToken = token.secretId;\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\ntoken = nomad.AclToken(\"token\",\n    type=\"client\",\n    policies=[\"dev\"])\npulumi.export(\"nomadToken\", token.secret_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var token = new Nomad.AclToken(\"token\", new()\n    {\n        Type = \"client\",\n        Policies = new[]\n        {\n            \"dev\",\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"nomadToken\"] = token.SecretId,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttoken, err := nomad.NewAclToken(ctx, \"token\", \u0026nomad.AclTokenArgs{\n\t\t\tType: pulumi.String(\"client\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"nomadToken\", token.SecretId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.AclToken;\nimport com.pulumi.nomad.AclTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var token = new AclToken(\"token\", AclTokenArgs.builder()\n            .type(\"client\")\n            .policies(\"dev\")\n            .build());\n\n        ctx.export(\"nomadToken\", token.secretId());\n    }\n}\n```\n```yaml\nresources:\n  token:\n    type: nomad:AclToken\n    properties:\n      type: client\n      policies:\n        - dev\noutputs:\n  nomadToken: ${token.secretId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "accessorId": {
                    "type": "string",
                    "description": "`(string)` - A non-sensitive identifier for this token that\ncan be logged and shared safely without granting any access to the cluster.\n"
                },
                "createTime": {
                    "type": "string",
                    "description": "`(string)` - The timestamp the token was created.\n"
                },
                "expirationTime": {
                    "type": "string",
                    "description": "`(string)` - The timestamp after which the token is\nconsidered expired and eligible for destruction.\n"
                },
                "expirationTtl": {
                    "type": "string",
                    "description": "`(string: \"\")` - Provides a TTL for the token in the form of\na time duration such as `\"5m\"` or `\"1h\"`.\n\nIn addition to the above arguments, the following attributes are exported and\ncan be referenced:\n"
                },
                "global": {
                    "type": "boolean",
                    "description": "`(bool: false)` - Whether the token should be replicated to all\nregions, or if it will only be used in the region it was created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \"\")` - A human-friendly name for this token.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`(set: [])` - A set of policy names to associate with this\ntoken. Must be set on `client`-type tokens, must not be set on\n`management`-type tokens. Policies do not need to exist before being\nused here.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/AclTokenRole:AclTokenRole"
                    },
                    "description": "`(set: [])` - The list of roles attached to the token. Each entry has\n`name` and `id` attributes. It may be used multiple times.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "`(string)` - The token value itself, which is presented for\naccess to the cluster.\n",
                    "secret": true
                },
                "type": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The type of token this is. Use `client`\nfor tokens that will have policies associated with them. Use `management`\nfor tokens that can perform any action.\n"
                }
            },
            "required": [
                "accessorId",
                "createTime",
                "expirationTime",
                "name",
                "secretId",
                "type"
            ],
            "inputProperties": {
                "expirationTtl": {
                    "type": "string",
                    "description": "`(string: \"\")` - Provides a TTL for the token in the form of\na time duration such as `\"5m\"` or `\"1h\"`.\n\nIn addition to the above arguments, the following attributes are exported and\ncan be referenced:\n",
                    "willReplaceOnChanges": true
                },
                "global": {
                    "type": "boolean",
                    "description": "`(bool: false)` - Whether the token should be replicated to all\nregions, or if it will only be used in the region it was created in.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \"\")` - A human-friendly name for this token.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "`(set: [])` - A set of policy names to associate with this\ntoken. Must be set on `client`-type tokens, must not be set on\n`management`-type tokens. Policies do not need to exist before being\nused here.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/AclTokenRole:AclTokenRole"
                    },
                    "description": "`(set: [])` - The list of roles attached to the token. Each entry has\n`name` and `id` attributes. It may be used multiple times.\n"
                },
                "type": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The type of token this is. Use `client`\nfor tokens that will have policies associated with them. Use `management`\nfor tokens that can perform any action.\n"
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclToken resources.\n",
                "properties": {
                    "accessorId": {
                        "type": "string",
                        "description": "`(string)` - A non-sensitive identifier for this token that\ncan be logged and shared safely without granting any access to the cluster.\n"
                    },
                    "createTime": {
                        "type": "string",
                        "description": "`(string)` - The timestamp the token was created.\n"
                    },
                    "expirationTime": {
                        "type": "string",
                        "description": "`(string)` - The timestamp after which the token is\nconsidered expired and eligible for destruction.\n"
                    },
                    "expirationTtl": {
                        "type": "string",
                        "description": "`(string: \"\")` - Provides a TTL for the token in the form of\na time duration such as `\"5m\"` or `\"1h\"`.\n\nIn addition to the above arguments, the following attributes are exported and\ncan be referenced:\n",
                        "willReplaceOnChanges": true
                    },
                    "global": {
                        "type": "boolean",
                        "description": "`(bool: false)` - Whether the token should be replicated to all\nregions, or if it will only be used in the region it was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \"\")` - A human-friendly name for this token.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "`(set: [])` - A set of policy names to associate with this\ntoken. Must be set on `client`-type tokens, must not be set on\n`management`-type tokens. Policies do not need to exist before being\nused here.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/AclTokenRole:AclTokenRole"
                        },
                        "description": "`(set: [])` - The list of roles attached to the token. Each entry has\n`name` and `id` attributes. It may be used multiple times.\n"
                    },
                    "secretId": {
                        "type": "string",
                        "description": "`(string)` - The token value itself, which is presented for\naccess to the cluster.\n",
                        "secret": true
                    },
                    "type": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The type of token this is. Use `client`\nfor tokens that will have policies associated with them. Use `management`\nfor tokens that can perform any action.\n"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/csiVolume:CsiVolume": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/CsiVolumeCapability:CsiVolumeCapability"
                    },
                    "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n"
                },
                "capacity": {
                    "type": "integer"
                },
                "capacityMax": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a maximum volume size. This may not be supported by all storage providers.\n"
                },
                "capacityMaxBytes": {
                    "type": "integer"
                },
                "capacityMin": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a minimum volume size. This may not be supported by all storage providers.\n"
                },
                "capacityMinBytes": {
                    "type": "integer"
                },
                "cloneId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The external ID of an existing volume to restore. If ommited, the volume will be created from scratch. Conflicts with `snapshot_id`.\n"
                },
                "context": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The volume context provided by the storage provider"
                },
                "controllerRequired": {
                    "type": "boolean"
                },
                "controllersExpected": {
                    "type": "integer"
                },
                "controllersHealthy": {
                    "type": "integer"
                },
                "externalId": {
                    "type": "string",
                    "description": "The ID of the physical volume from the storage provider."
                },
                "mountOptions": {
                    "$ref": "#/types/nomad:index/CsiVolumeMountOptions:CsiVolumeMountOptions",
                    "description": "`(block: optional)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \"default\")` - The namespace in which to register the volume.\n"
                },
                "nodesExpected": {
                    "type": "integer"
                },
                "nodesHealthy": {
                    "type": "integer"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: optional)` An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n"
                },
                "pluginProvider": {
                    "type": "string"
                },
                "pluginProviderVersion": {
                    "type": "string"
                },
                "schedulable": {
                    "type": "boolean"
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: optional)` An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                    "secret": true
                },
                "snapshotId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The external ID of a snapshot to restore. If ommited, the volume will be created from scratch. Conflicts with `clone_id`.\n"
                },
                "topologies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/CsiVolumeTopology:CsiVolumeTopology"
                    }
                },
                "topologyRequest": {
                    "$ref": "#/types/nomad:index/CsiVolumeTopologyRequest:CsiVolumeTopologyRequest",
                    "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n"
                },
                "volumeId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n"
                }
            },
            "required": [
                "capabilities",
                "capacity",
                "capacityMaxBytes",
                "capacityMinBytes",
                "context",
                "controllerRequired",
                "controllersExpected",
                "controllersHealthy",
                "externalId",
                "name",
                "nodesExpected",
                "nodesHealthy",
                "pluginId",
                "pluginProvider",
                "pluginProviderVersion",
                "schedulable",
                "topologies",
                "volumeId"
            ],
            "inputProperties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/CsiVolumeCapability:CsiVolumeCapability"
                    },
                    "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n",
                    "willReplaceOnChanges": true
                },
                "capacityMax": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a maximum volume size. This may not be supported by all storage providers.\n"
                },
                "capacityMin": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a minimum volume size. This may not be supported by all storage providers.\n"
                },
                "cloneId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The external ID of an existing volume to restore. If ommited, the volume will be created from scratch. Conflicts with `snapshot_id`.\n",
                    "willReplaceOnChanges": true
                },
                "mountOptions": {
                    "$ref": "#/types/nomad:index/CsiVolumeMountOptions:CsiVolumeMountOptions",
                    "description": "`(block: optional)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \"default\")` - The namespace in which to register the volume.\n",
                    "willReplaceOnChanges": true
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: optional)` An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n",
                    "willReplaceOnChanges": true
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: optional)` An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                    "secret": true
                },
                "snapshotId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The external ID of a snapshot to restore. If ommited, the volume will be created from scratch. Conflicts with `clone_id`.\n",
                    "willReplaceOnChanges": true
                },
                "topologyRequest": {
                    "$ref": "#/types/nomad:index/CsiVolumeTopologyRequest:CsiVolumeTopologyRequest",
                    "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n",
                    "willReplaceOnChanges": true
                },
                "volumeId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "capabilities",
                "pluginId",
                "volumeId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CsiVolume resources.\n",
                "properties": {
                    "capabilities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/CsiVolumeCapability:CsiVolumeCapability"
                        },
                        "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "capacity": {
                        "type": "integer"
                    },
                    "capacityMax": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Option to signal a maximum volume size. This may not be supported by all storage providers.\n"
                    },
                    "capacityMaxBytes": {
                        "type": "integer"
                    },
                    "capacityMin": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Option to signal a minimum volume size. This may not be supported by all storage providers.\n"
                    },
                    "capacityMinBytes": {
                        "type": "integer"
                    },
                    "cloneId": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - The external ID of an existing volume to restore. If ommited, the volume will be created from scratch. Conflicts with `snapshot_id`.\n",
                        "willReplaceOnChanges": true
                    },
                    "context": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The volume context provided by the storage provider"
                    },
                    "controllerRequired": {
                        "type": "boolean"
                    },
                    "controllersExpected": {
                        "type": "integer"
                    },
                    "controllersHealthy": {
                        "type": "integer"
                    },
                    "externalId": {
                        "type": "string",
                        "description": "The ID of the physical volume from the storage provider."
                    },
                    "mountOptions": {
                        "$ref": "#/types/nomad:index/CsiVolumeMountOptions:CsiVolumeMountOptions",
                        "description": "`(block: optional)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "`(string: \"default\")` - The namespace in which to register the volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodesExpected": {
                        "type": "integer"
                    },
                    "nodesHealthy": {
                        "type": "integer"
                    },
                    "parameters": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: optional)` An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                    },
                    "pluginId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "pluginProvider": {
                        "type": "string"
                    },
                    "pluginProviderVersion": {
                        "type": "string"
                    },
                    "schedulable": {
                        "type": "boolean"
                    },
                    "secrets": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: optional)` An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                        "secret": true
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - The external ID of a snapshot to restore. If ommited, the volume will be created from scratch. Conflicts with `clone_id`.\n",
                        "willReplaceOnChanges": true
                    },
                    "topologies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/CsiVolumeTopology:CsiVolumeTopology"
                        }
                    },
                    "topologyRequest": {
                        "$ref": "#/types/nomad:index/CsiVolumeTopologyRequest:CsiVolumeTopologyRequest",
                        "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n",
                        "willReplaceOnChanges": true
                    },
                    "volumeId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/csiVolumeRegistration:CsiVolumeRegistration": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/CsiVolumeRegistrationCapability:CsiVolumeRegistrationCapability"
                    },
                    "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n"
                },
                "capacity": {
                    "type": "integer"
                },
                "capacityMax": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a maximum volume size. This may not be supported by all storage providers.\n"
                },
                "capacityMaxBytes": {
                    "type": "integer"
                },
                "capacityMin": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a minimum volume size. This may not be supported by all storage providers.\n"
                },
                "capacityMinBytes": {
                    "type": "integer"
                },
                "context": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to validate the volume.\n"
                },
                "controllerRequired": {
                    "type": "boolean"
                },
                "controllersExpected": {
                    "type": "integer"
                },
                "controllersHealthy": {
                    "type": "integer"
                },
                "deregisterOnDestroy": {
                    "type": "boolean",
                    "description": "`(boolean: true)` - If true, the volume will be deregistered on destroy.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the physical volume from the storage provider.\n"
                },
                "mountOptions": {
                    "$ref": "#/types/nomad:index/CsiVolumeRegistrationMountOptions:CsiVolumeRegistrationMountOptions",
                    "description": "`(block: \u003coptional\u003e)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \"default\")` - The namespace in which to register the volume.\n"
                },
                "nodesExpected": {
                    "type": "integer"
                },
                "nodesHealthy": {
                    "type": "integer"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n"
                },
                "pluginProvider": {
                    "type": "string"
                },
                "pluginProviderVersion": {
                    "type": "string"
                },
                "schedulable": {
                    "type": "boolean"
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                    "secret": true
                },
                "topologies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/CsiVolumeRegistrationTopology:CsiVolumeRegistrationTopology"
                    }
                },
                "topologyRequest": {
                    "$ref": "#/types/nomad:index/CsiVolumeRegistrationTopologyRequest:CsiVolumeRegistrationTopologyRequest",
                    "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n"
                },
                "volumeId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n"
                }
            },
            "required": [
                "capacity",
                "capacityMaxBytes",
                "capacityMinBytes",
                "controllerRequired",
                "controllersExpected",
                "controllersHealthy",
                "externalId",
                "name",
                "nodesExpected",
                "nodesHealthy",
                "pluginId",
                "pluginProvider",
                "pluginProviderVersion",
                "schedulable",
                "topologies",
                "volumeId"
            ],
            "inputProperties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/CsiVolumeRegistrationCapability:CsiVolumeRegistrationCapability"
                    },
                    "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n"
                },
                "capacityMax": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a maximum volume size. This may not be supported by all storage providers.\n"
                },
                "capacityMin": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a minimum volume size. This may not be supported by all storage providers.\n"
                },
                "context": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to validate the volume.\n"
                },
                "deregisterOnDestroy": {
                    "type": "boolean",
                    "description": "`(boolean: true)` - If true, the volume will be deregistered on destroy.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the physical volume from the storage provider.\n",
                    "willReplaceOnChanges": true
                },
                "mountOptions": {
                    "$ref": "#/types/nomad:index/CsiVolumeRegistrationMountOptions:CsiVolumeRegistrationMountOptions",
                    "description": "`(block: \u003coptional\u003e)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \"default\")` - The namespace in which to register the volume.\n",
                    "willReplaceOnChanges": true
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n",
                    "willReplaceOnChanges": true
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                    "secret": true
                },
                "topologyRequest": {
                    "$ref": "#/types/nomad:index/CsiVolumeRegistrationTopologyRequest:CsiVolumeRegistrationTopologyRequest",
                    "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n",
                    "willReplaceOnChanges": true
                },
                "volumeId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "externalId",
                "pluginId",
                "volumeId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CsiVolumeRegistration resources.\n",
                "properties": {
                    "capabilities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/CsiVolumeRegistrationCapability:CsiVolumeRegistrationCapability"
                        },
                        "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n"
                    },
                    "capacity": {
                        "type": "integer"
                    },
                    "capacityMax": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Option to signal a maximum volume size. This may not be supported by all storage providers.\n"
                    },
                    "capacityMaxBytes": {
                        "type": "integer"
                    },
                    "capacityMin": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Option to signal a minimum volume size. This may not be supported by all storage providers.\n"
                    },
                    "capacityMinBytes": {
                        "type": "integer"
                    },
                    "context": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to validate the volume.\n"
                    },
                    "controllerRequired": {
                        "type": "boolean"
                    },
                    "controllersExpected": {
                        "type": "integer"
                    },
                    "controllersHealthy": {
                        "type": "integer"
                    },
                    "deregisterOnDestroy": {
                        "type": "boolean",
                        "description": "`(boolean: true)` - If true, the volume will be deregistered on destroy.\n"
                    },
                    "externalId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The ID of the physical volume from the storage provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "mountOptions": {
                        "$ref": "#/types/nomad:index/CsiVolumeRegistrationMountOptions:CsiVolumeRegistrationMountOptions",
                        "description": "`(block: \u003coptional\u003e)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "`(string: \"default\")` - The namespace in which to register the volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodesExpected": {
                        "type": "integer"
                    },
                    "nodesHealthy": {
                        "type": "integer"
                    },
                    "parameters": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                    },
                    "pluginId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "pluginProvider": {
                        "type": "string"
                    },
                    "pluginProviderVersion": {
                        "type": "string"
                    },
                    "schedulable": {
                        "type": "boolean"
                    },
                    "secrets": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                        "secret": true
                    },
                    "topologies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/CsiVolumeRegistrationTopology:CsiVolumeRegistrationTopology"
                        }
                    },
                    "topologyRequest": {
                        "$ref": "#/types/nomad:index/CsiVolumeRegistrationTopologyRequest:CsiVolumeRegistrationTopologyRequest",
                        "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n",
                        "willReplaceOnChanges": true
                    },
                    "volumeId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/dynamicHostVolume:DynamicHostVolume": {
            "description": "layout: \"nomad\"\npage_title: \"Nomad: nomad.DynamicHostVolume\"\nsidebar_current: \"docs-nomad-resource-dynamic-host-volume\"\ndescription: |-\n  Manages the lifecycle of creating and deleting dynamic host volumes.\n---\n\nCreates and registers a dynamic host volume in Nomad. Note that Nomad supports\ntwo workflows for dynamic host volumes: create and register. Both resources\nresult in the same data source with the same outputs.\n\n\u003e **Warning:** Destroying this resource **will result in data loss**. Use the\n  [`prevent_destroy`][tf_docs_prevent_destroy] directive to avoid accidental\n  deletions.\n\n\n## Example Usage\n\nCreating a dynamic host volume:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = new nomad.DynamicHostVolume(\"example\", {\n    name: \"example\",\n    namespace: \"prod\",\n    pluginId: \"mkdir\",\n    capacityMax: \"12 GiB\",\n    capacityMin: \"1.0 GiB\",\n    capabilities: [{\n        accessMode: \"single-node-writer\",\n        attachmentMode: \"file-system\",\n    }],\n    constraints: [{\n        attribute: `${attr.kernel.name}`,\n        value: \"linux\",\n    }],\n    parameters: {\n        some_key: \"some_value\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.DynamicHostVolume(\"example\",\n    name=\"example\",\n    namespace=\"prod\",\n    plugin_id=\"mkdir\",\n    capacity_max=\"12 GiB\",\n    capacity_min=\"1.0 GiB\",\n    capabilities=[{\n        \"access_mode\": \"single-node-writer\",\n        \"attachment_mode\": \"file-system\",\n    }],\n    constraints=[{\n        \"attribute\": \"${attr.kernel.name}\",\n        \"value\": \"linux\",\n    }],\n    parameters={\n        \"some_key\": \"some_value\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Nomad.DynamicHostVolume(\"example\", new()\n    {\n        Name = \"example\",\n        Namespace = \"prod\",\n        PluginId = \"mkdir\",\n        CapacityMax = \"12 GiB\",\n        CapacityMin = \"1.0 GiB\",\n        Capabilities = new[]\n        {\n            new Nomad.Inputs.DynamicHostVolumeCapabilityArgs\n            {\n                AccessMode = \"single-node-writer\",\n                AttachmentMode = \"file-system\",\n            },\n        },\n        Constraints = new[]\n        {\n            new Nomad.Inputs.DynamicHostVolumeConstraintArgs\n            {\n                Attribute = \"${attr.kernel.name}\",\n                Value = \"linux\",\n            },\n        },\n        Parameters = \n        {\n            { \"some_key\", \"some_value\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewDynamicHostVolume(ctx, \"example\", \u0026nomad.DynamicHostVolumeArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tNamespace:   pulumi.String(\"prod\"),\n\t\t\tPluginId:    pulumi.String(\"mkdir\"),\n\t\t\tCapacityMax: pulumi.String(\"12 GiB\"),\n\t\t\tCapacityMin: pulumi.String(\"1.0 GiB\"),\n\t\t\tCapabilities: nomad.DynamicHostVolumeCapabilityArray{\n\t\t\t\t\u0026nomad.DynamicHostVolumeCapabilityArgs{\n\t\t\t\t\tAccessMode:     pulumi.String(\"single-node-writer\"),\n\t\t\t\t\tAttachmentMode: pulumi.String(\"file-system\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tConstraints: nomad.DynamicHostVolumeConstraintArray{\n\t\t\t\t\u0026nomad.DynamicHostVolumeConstraintArgs{\n\t\t\t\t\tAttribute: pulumi.Sprintf(\"${attr.kernel.name}\"),\n\t\t\t\t\tValue:     pulumi.String(\"linux\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tParameters: pulumi.StringMap{\n\t\t\t\t\"some_key\": pulumi.String(\"some_value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.DynamicHostVolume;\nimport com.pulumi.nomad.DynamicHostVolumeArgs;\nimport com.pulumi.nomad.inputs.DynamicHostVolumeCapabilityArgs;\nimport com.pulumi.nomad.inputs.DynamicHostVolumeConstraintArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new DynamicHostVolume(\"example\", DynamicHostVolumeArgs.builder()\n            .name(\"example\")\n            .namespace(\"prod\")\n            .pluginId(\"mkdir\")\n            .capacityMax(\"12 GiB\")\n            .capacityMin(\"1.0 GiB\")\n            .capabilities(DynamicHostVolumeCapabilityArgs.builder()\n                .accessMode(\"single-node-writer\")\n                .attachmentMode(\"file-system\")\n                .build())\n            .constraints(DynamicHostVolumeConstraintArgs.builder()\n                .attribute(\"${attr.kernel.name}\")\n                .value(\"linux\")\n                .build())\n            .parameters(Map.of(\"some_key\", \"some_value\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: nomad:DynamicHostVolume\n    properties:\n      name: example\n      namespace: prod\n      pluginId: mkdir\n      capacityMax: 12 GiB\n      capacityMin: 1.0 GiB\n      capabilities:\n        - accessMode: single-node-writer\n          attachmentMode: file-system\n      constraints:\n        - attribute: $${attr.kernel.name}\n          value: linux\n      parameters:\n        some_key: some_value\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/DynamicHostVolumeCapability:DynamicHostVolumeCapability"
                    },
                    "description": "`(block: \u003coptional\u003e)` - Option for validating the capability of a\nvolume. Each capability block has the following attributes:\n"
                },
                "capacity": {
                    "type": "string",
                    "description": "Provisioned capacity"
                },
                "capacityBytes": {
                    "type": "integer"
                },
                "capacityMax": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option for requesting a maximum\ncapacity, in bytes. The capacity of a volume may be the physical size of a\ndisk, or a quota, depending on the plugin. The specific size of the resulting\nvolume is somewhere between `capacity_min` and `capacity_max`; the exact\nbehavior is up to the plugin. If you want to specify an exact size, set\n`capacity_min` and `capacity_max` to the same value. Accepts human-friendly\nsuffixes such as `\"100GiB\"`. Plugins that cannot restrict the size of volumes\nmay ignore this field.\n"
                },
                "capacityMaxBytes": {
                    "type": "integer"
                },
                "capacityMin": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option for requesting a minimum\ncapacity, in bytes. The capacity of a volume may be the physical size of a\ndisk, or a quota, depending on the plugin. The specific size of the resulting\nvolume is somewhere between `capacity_min` and `capacity_max`; the exact\nbehavior is up to the plugin. If you want to specify an exact size, set\n`capacity_min` and `capacity_max` to the same value. Accepts human-friendly\nsuffixes such as `\"100GiB\"`. Plugins that cannot restrict the size of volumes\nmay ignore this field.\n"
                },
                "capacityMinBytes": {
                    "type": "integer"
                },
                "constraints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/DynamicHostVolumeConstraint:DynamicHostVolumeConstraint"
                    },
                    "description": "`(block: \u003coptional\u003e)` - A restriction on the eligible nodes where\na volume can be created, similar to the [`constraint`][] block on a Nomad job\nspecification.. You can provide multiple `constraint` blocks to add more\nconstraints. Each constraint block has the following attributes.\n"
                },
                "hostPath": {
                    "type": "string",
                    "description": "Host path"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The name of the volume, which is used as the\n[`volume.source`][volume_source] field in job specifications that claim this\nvolume. Host volume names must be unique per node. Names are visible to any\nuser with `node:read` ACL, even across namespaces, so they should not be\ntreated as sensitive values.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The namespace of the volume. This field\noverrides the namespace provided by the `-namespace` flag or `NOMAD_NAMESPACE`\nenvironment variable. Defaults to `\"default\"` if unset.\n"
                },
                "nodeId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - A specific node where you would like the\nvolume to be created.\n"
                },
                "nodePool": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - A specific node pool where you would like\nthe volume to be created. If you also provide `node_id`, the node must be in the\nprovided `node_pool`.\n"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map\u003cstring|string\u003e: \u003coptional\u003e)` - A key-value map of strings\npassed directly to the plugin to configure the volume. The details of these\nparameters are specific to the plugin.\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "Plugin ID"
                },
                "state": {
                    "type": "string",
                    "description": "State"
                }
            },
            "required": [
                "capabilities",
                "capacity",
                "capacityBytes",
                "capacityMaxBytes",
                "capacityMinBytes",
                "hostPath",
                "name",
                "nodeId",
                "nodePool",
                "pluginId",
                "state"
            ],
            "inputProperties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/DynamicHostVolumeCapability:DynamicHostVolumeCapability"
                    },
                    "description": "`(block: \u003coptional\u003e)` - Option for validating the capability of a\nvolume. Each capability block has the following attributes:\n"
                },
                "capacityMax": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option for requesting a maximum\ncapacity, in bytes. The capacity of a volume may be the physical size of a\ndisk, or a quota, depending on the plugin. The specific size of the resulting\nvolume is somewhere between `capacity_min` and `capacity_max`; the exact\nbehavior is up to the plugin. If you want to specify an exact size, set\n`capacity_min` and `capacity_max` to the same value. Accepts human-friendly\nsuffixes such as `\"100GiB\"`. Plugins that cannot restrict the size of volumes\nmay ignore this field.\n"
                },
                "capacityMin": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option for requesting a minimum\ncapacity, in bytes. The capacity of a volume may be the physical size of a\ndisk, or a quota, depending on the plugin. The specific size of the resulting\nvolume is somewhere between `capacity_min` and `capacity_max`; the exact\nbehavior is up to the plugin. If you want to specify an exact size, set\n`capacity_min` and `capacity_max` to the same value. Accepts human-friendly\nsuffixes such as `\"100GiB\"`. Plugins that cannot restrict the size of volumes\nmay ignore this field.\n"
                },
                "constraints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/DynamicHostVolumeConstraint:DynamicHostVolumeConstraint"
                    },
                    "description": "`(block: \u003coptional\u003e)` - A restriction on the eligible nodes where\na volume can be created, similar to the [`constraint`][] block on a Nomad job\nspecification.. You can provide multiple `constraint` blocks to add more\nconstraints. Each constraint block has the following attributes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The name of the volume, which is used as the\n[`volume.source`][volume_source] field in job specifications that claim this\nvolume. Host volume names must be unique per node. Names are visible to any\nuser with `node:read` ACL, even across namespaces, so they should not be\ntreated as sensitive values.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The namespace of the volume. This field\noverrides the namespace provided by the `-namespace` flag or `NOMAD_NAMESPACE`\nenvironment variable. Defaults to `\"default\"` if unset.\n"
                },
                "nodeId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - A specific node where you would like the\nvolume to be created.\n",
                    "willReplaceOnChanges": true
                },
                "nodePool": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - A specific node pool where you would like\nthe volume to be created. If you also provide `node_id`, the node must be in the\nprovided `node_pool`.\n"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map\u003cstring|string\u003e: \u003coptional\u003e)` - A key-value map of strings\npassed directly to the plugin to configure the volume. The details of these\nparameters are specific to the plugin.\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "Plugin ID"
                }
            },
            "requiredInputs": [
                "capabilities",
                "pluginId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DynamicHostVolume resources.\n",
                "properties": {
                    "capabilities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/DynamicHostVolumeCapability:DynamicHostVolumeCapability"
                        },
                        "description": "`(block: \u003coptional\u003e)` - Option for validating the capability of a\nvolume. Each capability block has the following attributes:\n"
                    },
                    "capacity": {
                        "type": "string",
                        "description": "Provisioned capacity"
                    },
                    "capacityBytes": {
                        "type": "integer"
                    },
                    "capacityMax": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Option for requesting a maximum\ncapacity, in bytes. The capacity of a volume may be the physical size of a\ndisk, or a quota, depending on the plugin. The specific size of the resulting\nvolume is somewhere between `capacity_min` and `capacity_max`; the exact\nbehavior is up to the plugin. If you want to specify an exact size, set\n`capacity_min` and `capacity_max` to the same value. Accepts human-friendly\nsuffixes such as `\"100GiB\"`. Plugins that cannot restrict the size of volumes\nmay ignore this field.\n"
                    },
                    "capacityMaxBytes": {
                        "type": "integer"
                    },
                    "capacityMin": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Option for requesting a minimum\ncapacity, in bytes. The capacity of a volume may be the physical size of a\ndisk, or a quota, depending on the plugin. The specific size of the resulting\nvolume is somewhere between `capacity_min` and `capacity_max`; the exact\nbehavior is up to the plugin. If you want to specify an exact size, set\n`capacity_min` and `capacity_max` to the same value. Accepts human-friendly\nsuffixes such as `\"100GiB\"`. Plugins that cannot restrict the size of volumes\nmay ignore this field.\n"
                    },
                    "capacityMinBytes": {
                        "type": "integer"
                    },
                    "constraints": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/DynamicHostVolumeConstraint:DynamicHostVolumeConstraint"
                        },
                        "description": "`(block: \u003coptional\u003e)` - A restriction on the eligible nodes where\na volume can be created, similar to the [`constraint`][] block on a Nomad job\nspecification.. You can provide multiple `constraint` blocks to add more\nconstraints. Each constraint block has the following attributes.\n"
                    },
                    "hostPath": {
                        "type": "string",
                        "description": "Host path"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The name of the volume, which is used as the\n[`volume.source`][volume_source] field in job specifications that claim this\nvolume. Host volume names must be unique per node. Names are visible to any\nuser with `node:read` ACL, even across namespaces, so they should not be\ntreated as sensitive values.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - The namespace of the volume. This field\noverrides the namespace provided by the `-namespace` flag or `NOMAD_NAMESPACE`\nenvironment variable. Defaults to `\"default\"` if unset.\n"
                    },
                    "nodeId": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - A specific node where you would like the\nvolume to be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodePool": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - A specific node pool where you would like\nthe volume to be created. If you also provide `node_id`, the node must be in the\nprovided `node_pool`.\n"
                    },
                    "parameters": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map\u003cstring|string\u003e: \u003coptional\u003e)` - A key-value map of strings\npassed directly to the plugin to configure the volume. The details of these\nparameters are specific to the plugin.\n"
                    },
                    "pluginId": {
                        "type": "string",
                        "description": "Plugin ID"
                    },
                    "state": {
                        "type": "string",
                        "description": "State"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/dynamicHostVolumeRegistration:DynamicHostVolumeRegistration": {
            "description": "Registers a dynamic host volume in Nomad that has already been created. Note\nthat Nomad supports two workflows for dynamic host volumes: create and\nregister. Both resources result in the same data source with the same outputs.\n",
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/DynamicHostVolumeRegistrationCapability:DynamicHostVolumeRegistrationCapability"
                    },
                    "description": "`(block: \u003coptional\u003e)` - Option for validating the capability of a\nvolume. Each capability block has the following attributes:\n"
                },
                "capacity": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The size of a volume in bytes. Either the\nphysical size of a disk or a quota, depending on the plugin. This field must\nbe between the `capacity_min` and `capacity_max` values unless they are\nomitted. Accepts human-friendly suffixes such as `\"100GiB\"`.\n"
                },
                "capacityBytes": {
                    "type": "integer"
                },
                "capacityMaxBytes": {
                    "type": "integer"
                },
                "capacityMinBytes": {
                    "type": "integer"
                },
                "constraints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/DynamicHostVolumeRegistrationConstraint:DynamicHostVolumeRegistrationConstraint"
                    },
                    "description": "Constraints"
                },
                "hostPath": {
                    "type": "string",
                    "description": "`(string)` - The path on disk where the volume exists.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The name of the volume, which is used as the\n[`volume.source`][volume_source] field in job specifications that claim this\nvolume. Host volume names must be unique per node. Names are visible to any\nuser with `node:read` ACL, even across namespaces, so they should not be\ntreated as sensitive values.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The namespace of the volume. This field\noverrides the namespace provided by the `-namespace` flag or `NOMAD_NAMESPACE`\nenvironment variable. Defaults to `\"default\"` if unset.\n"
                },
                "nodeId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A specific node where the volume is\nmounted.\n"
                },
                "nodePool": {
                    "type": "string",
                    "description": "Node pool"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map\u003cstring|string\u003e: \u003coptional\u003e)` - A key-value map of strings\npassed directly to the plugin to configure the volume. The details of these\nparameters are specific to the plugin.\n\n\n[`access_mode`]: /nomad/docs/other-specifications/volume/capability#access_mode\n[`attachment_mode`]: /nomad/docs/other-specifications/volume/capability#attachment_mode\n[volume_source]: /nomad/docs/job-specification/volume#source\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "Plugin ID"
                },
                "state": {
                    "type": "string",
                    "description": "State"
                }
            },
            "required": [
                "capabilities",
                "capacityBytes",
                "capacityMaxBytes",
                "capacityMinBytes",
                "constraints",
                "hostPath",
                "name",
                "nodeId",
                "nodePool",
                "pluginId",
                "state"
            ],
            "inputProperties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/DynamicHostVolumeRegistrationCapability:DynamicHostVolumeRegistrationCapability"
                    },
                    "description": "`(block: \u003coptional\u003e)` - Option for validating the capability of a\nvolume. Each capability block has the following attributes:\n"
                },
                "capacity": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The size of a volume in bytes. Either the\nphysical size of a disk or a quota, depending on the plugin. This field must\nbe between the `capacity_min` and `capacity_max` values unless they are\nomitted. Accepts human-friendly suffixes such as `\"100GiB\"`.\n"
                },
                "hostPath": {
                    "type": "string",
                    "description": "`(string)` - The path on disk where the volume exists.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The name of the volume, which is used as the\n[`volume.source`][volume_source] field in job specifications that claim this\nvolume. Host volume names must be unique per node. Names are visible to any\nuser with `node:read` ACL, even across namespaces, so they should not be\ntreated as sensitive values.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The namespace of the volume. This field\noverrides the namespace provided by the `-namespace` flag or `NOMAD_NAMESPACE`\nenvironment variable. Defaults to `\"default\"` if unset.\n"
                },
                "nodeId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A specific node where the volume is\nmounted.\n"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map\u003cstring|string\u003e: \u003coptional\u003e)` - A key-value map of strings\npassed directly to the plugin to configure the volume. The details of these\nparameters are specific to the plugin.\n\n\n[`access_mode`]: /nomad/docs/other-specifications/volume/capability#access_mode\n[`attachment_mode`]: /nomad/docs/other-specifications/volume/capability#attachment_mode\n[volume_source]: /nomad/docs/job-specification/volume#source\n"
                }
            },
            "requiredInputs": [
                "capabilities",
                "hostPath",
                "nodeId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DynamicHostVolumeRegistration resources.\n",
                "properties": {
                    "capabilities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/DynamicHostVolumeRegistrationCapability:DynamicHostVolumeRegistrationCapability"
                        },
                        "description": "`(block: \u003coptional\u003e)` - Option for validating the capability of a\nvolume. Each capability block has the following attributes:\n"
                    },
                    "capacity": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - The size of a volume in bytes. Either the\nphysical size of a disk or a quota, depending on the plugin. This field must\nbe between the `capacity_min` and `capacity_max` values unless they are\nomitted. Accepts human-friendly suffixes such as `\"100GiB\"`.\n"
                    },
                    "capacityBytes": {
                        "type": "integer"
                    },
                    "capacityMaxBytes": {
                        "type": "integer"
                    },
                    "capacityMinBytes": {
                        "type": "integer"
                    },
                    "constraints": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/DynamicHostVolumeRegistrationConstraint:DynamicHostVolumeRegistrationConstraint"
                        },
                        "description": "Constraints"
                    },
                    "hostPath": {
                        "type": "string",
                        "description": "`(string)` - The path on disk where the volume exists.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The name of the volume, which is used as the\n[`volume.source`][volume_source] field in job specifications that claim this\nvolume. Host volume names must be unique per node. Names are visible to any\nuser with `node:read` ACL, even across namespaces, so they should not be\ntreated as sensitive values.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - The namespace of the volume. This field\noverrides the namespace provided by the `-namespace` flag or `NOMAD_NAMESPACE`\nenvironment variable. Defaults to `\"default\"` if unset.\n"
                    },
                    "nodeId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - A specific node where the volume is\nmounted.\n"
                    },
                    "nodePool": {
                        "type": "string",
                        "description": "Node pool"
                    },
                    "parameters": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map\u003cstring|string\u003e: \u003coptional\u003e)` - A key-value map of strings\npassed directly to the plugin to configure the volume. The details of these\nparameters are specific to the plugin.\n\n\n[`access_mode`]: /nomad/docs/other-specifications/volume/capability#access_mode\n[`attachment_mode`]: /nomad/docs/other-specifications/volume/capability#attachment_mode\n[volume_source]: /nomad/docs/job-specification/volume#source\n"
                    },
                    "pluginId": {
                        "type": "string",
                        "description": "Plugin ID"
                    },
                    "state": {
                        "type": "string",
                        "description": "State"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/externalVolume:ExternalVolume": {
            "description": "## Example Usage\n\nCreating a volume:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\n// It can sometimes be helpful to wait for a particular plugin to be available\nconst ebs = nomad.getPlugin({\n    pluginId: \"aws-ebs0\",\n    waitForHealthy: true,\n});\nconst mysqlVolume = new nomad.ExternalVolume(\"mysql_volume\", {\n    type: \"csi\",\n    pluginId: \"aws-ebs0\",\n    volumeId: \"mysql_volume\",\n    name: \"mysql_volume\",\n    capacityMin: \"10GiB\",\n    capacityMax: \"20GiB\",\n    capabilities: [{\n        accessMode: \"single-node-writer\",\n        attachmentMode: \"file-system\",\n    }],\n    mountOptions: {\n        fsType: \"ext4\",\n    },\n    topologyRequest: {\n        required: {\n            topologies: [\n                {\n                    segments: {\n                        rack: \"R1\",\n                        zone: \"us-east-1a\",\n                    },\n                },\n                {\n                    segments: {\n                        rack: \"R2\",\n                    },\n                },\n            ],\n        },\n    },\n}, {\n    dependsOn: [ebs],\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\n# It can sometimes be helpful to wait for a particular plugin to be available\nebs = nomad.get_plugin(plugin_id=\"aws-ebs0\",\n    wait_for_healthy=True)\nmysql_volume = nomad.ExternalVolume(\"mysql_volume\",\n    type=\"csi\",\n    plugin_id=\"aws-ebs0\",\n    volume_id=\"mysql_volume\",\n    name=\"mysql_volume\",\n    capacity_min=\"10GiB\",\n    capacity_max=\"20GiB\",\n    capabilities=[{\n        \"access_mode\": \"single-node-writer\",\n        \"attachment_mode\": \"file-system\",\n    }],\n    mount_options={\n        \"fs_type\": \"ext4\",\n    },\n    topology_request={\n        \"required\": {\n            \"topologies\": [\n                {\n                    \"segments\": {\n                        \"rack\": \"R1\",\n                        \"zone\": \"us-east-1a\",\n                    },\n                },\n                {\n                    \"segments\": {\n                        \"rack\": \"R2\",\n                    },\n                },\n            ],\n        },\n    },\n    opts = pulumi.ResourceOptions(depends_on=[ebs]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // It can sometimes be helpful to wait for a particular plugin to be available\n    var ebs = Nomad.GetPlugin.Invoke(new()\n    {\n        PluginId = \"aws-ebs0\",\n        WaitForHealthy = true,\n    });\n\n    var mysqlVolume = new Nomad.ExternalVolume(\"mysql_volume\", new()\n    {\n        Type = \"csi\",\n        PluginId = \"aws-ebs0\",\n        VolumeId = \"mysql_volume\",\n        Name = \"mysql_volume\",\n        CapacityMin = \"10GiB\",\n        CapacityMax = \"20GiB\",\n        Capabilities = new[]\n        {\n            new Nomad.Inputs.ExternalVolumeCapabilityArgs\n            {\n                AccessMode = \"single-node-writer\",\n                AttachmentMode = \"file-system\",\n            },\n        },\n        MountOptions = new Nomad.Inputs.ExternalVolumeMountOptionsArgs\n        {\n            FsType = \"ext4\",\n        },\n        TopologyRequest = new Nomad.Inputs.ExternalVolumeTopologyRequestArgs\n        {\n            Required = new Nomad.Inputs.ExternalVolumeTopologyRequestRequiredArgs\n            {\n                Topologies = new[]\n                {\n                    new Nomad.Inputs.ExternalVolumeTopologyRequestRequiredTopologyArgs\n                    {\n                        Segments = \n                        {\n                            { \"rack\", \"R1\" },\n                            { \"zone\", \"us-east-1a\" },\n                        },\n                    },\n                    new Nomad.Inputs.ExternalVolumeTopologyRequestRequiredTopologyArgs\n                    {\n                        Segments = \n                        {\n                            { \"rack\", \"R2\" },\n                        },\n                    },\n                },\n            },\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            ebs,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// It can sometimes be helpful to wait for a particular plugin to be available\n\t\tebs, err := nomad.GetPlugin(ctx, \u0026nomad.GetPluginArgs{\n\t\t\tPluginId:       \"aws-ebs0\",\n\t\t\tWaitForHealthy: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = nomad.NewExternalVolume(ctx, \"mysql_volume\", \u0026nomad.ExternalVolumeArgs{\n\t\t\tType:        pulumi.String(\"csi\"),\n\t\t\tPluginId:    pulumi.String(\"aws-ebs0\"),\n\t\t\tVolumeId:    pulumi.String(\"mysql_volume\"),\n\t\t\tName:        pulumi.String(\"mysql_volume\"),\n\t\t\tCapacityMin: pulumi.String(\"10GiB\"),\n\t\t\tCapacityMax: pulumi.String(\"20GiB\"),\n\t\t\tCapabilities: nomad.ExternalVolumeCapabilityArray{\n\t\t\t\t\u0026nomad.ExternalVolumeCapabilityArgs{\n\t\t\t\t\tAccessMode:     pulumi.String(\"single-node-writer\"),\n\t\t\t\t\tAttachmentMode: pulumi.String(\"file-system\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMountOptions: \u0026nomad.ExternalVolumeMountOptionsArgs{\n\t\t\t\tFsType: pulumi.String(\"ext4\"),\n\t\t\t},\n\t\t\tTopologyRequest: \u0026nomad.ExternalVolumeTopologyRequestArgs{\n\t\t\t\tRequired: \u0026nomad.ExternalVolumeTopologyRequestRequiredArgs{\n\t\t\t\t\tTopologies: nomad.ExternalVolumeTopologyRequestRequiredTopologyArray{\n\t\t\t\t\t\t\u0026nomad.ExternalVolumeTopologyRequestRequiredTopologyArgs{\n\t\t\t\t\t\t\tSegments: pulumi.StringMap{\n\t\t\t\t\t\t\t\t\"rack\": pulumi.String(\"R1\"),\n\t\t\t\t\t\t\t\t\"zone\": pulumi.String(\"us-east-1a\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026nomad.ExternalVolumeTopologyRequestRequiredTopologyArgs{\n\t\t\t\t\t\t\tSegments: pulumi.StringMap{\n\t\t\t\t\t\t\t\t\"rack\": pulumi.String(\"R2\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tebs,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetPluginArgs;\nimport com.pulumi.nomad.ExternalVolume;\nimport com.pulumi.nomad.ExternalVolumeArgs;\nimport com.pulumi.nomad.inputs.ExternalVolumeCapabilityArgs;\nimport com.pulumi.nomad.inputs.ExternalVolumeMountOptionsArgs;\nimport com.pulumi.nomad.inputs.ExternalVolumeTopologyRequestArgs;\nimport com.pulumi.nomad.inputs.ExternalVolumeTopologyRequestRequiredArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // It can sometimes be helpful to wait for a particular plugin to be available\n        final var ebs = NomadFunctions.getPlugin(GetPluginArgs.builder()\n            .pluginId(\"aws-ebs0\")\n            .waitForHealthy(true)\n            .build());\n\n        var mysqlVolume = new ExternalVolume(\"mysqlVolume\", ExternalVolumeArgs.builder()\n            .type(\"csi\")\n            .pluginId(\"aws-ebs0\")\n            .volumeId(\"mysql_volume\")\n            .name(\"mysql_volume\")\n            .capacityMin(\"10GiB\")\n            .capacityMax(\"20GiB\")\n            .capabilities(ExternalVolumeCapabilityArgs.builder()\n                .accessMode(\"single-node-writer\")\n                .attachmentMode(\"file-system\")\n                .build())\n            .mountOptions(ExternalVolumeMountOptionsArgs.builder()\n                .fsType(\"ext4\")\n                .build())\n            .topologyRequest(ExternalVolumeTopologyRequestArgs.builder()\n                .required(ExternalVolumeTopologyRequestRequiredArgs.builder()\n                    .topologies(                    \n                        ExternalVolumeTopologyRequestRequiredTopologyArgs.builder()\n                            .segments(Map.ofEntries(\n                                Map.entry(\"rack\", \"R1\"),\n                                Map.entry(\"zone\", \"us-east-1a\")\n                            ))\n                            .build(),\n                        ExternalVolumeTopologyRequestRequiredTopologyArgs.builder()\n                            .segments(Map.of(\"rack\", \"R2\"))\n                            .build())\n                    .build())\n                .build())\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(ebs)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  mysqlVolume:\n    type: nomad:ExternalVolume\n    name: mysql_volume\n    properties:\n      type: csi\n      pluginId: aws-ebs0\n      volumeId: mysql_volume\n      name: mysql_volume\n      capacityMin: 10GiB\n      capacityMax: 20GiB\n      capabilities:\n        - accessMode: single-node-writer\n          attachmentMode: file-system\n      mountOptions:\n        fsType: ext4\n      topologyRequest:\n        required:\n          topologies:\n            - segments:\n                rack: R1\n                zone: us-east-1a\n            - segments:\n                rack: R2\n    options:\n      dependsOn:\n        - ${ebs}\nvariables:\n  # It can sometimes be helpful to wait for a particular plugin to be available\n  ebs:\n    fn::invoke:\n      function: nomad:getPlugin\n      arguments:\n        pluginId: aws-ebs0\n        waitForHealthy: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/ExternalVolumeCapability:ExternalVolumeCapability"
                    },
                    "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n"
                },
                "capacityMax": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a maximum volume size. This may not be supported by all storage providers.\n"
                },
                "capacityMin": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a minimum volume size. This may not be supported by all storage providers.\n"
                },
                "cloneId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The external ID of an existing volume to restore. If ommited, the volume will be created from scratch. Conflicts with `snapshot_id`.\n"
                },
                "controllerRequired": {
                    "type": "boolean"
                },
                "controllersExpected": {
                    "type": "integer"
                },
                "controllersHealthy": {
                    "type": "integer"
                },
                "mountOptions": {
                    "$ref": "#/types/nomad:index/ExternalVolumeMountOptions:ExternalVolumeMountOptions",
                    "description": "`(block: optional)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \"default\")` - The namespace in which to register the volume.\n"
                },
                "nodesExpected": {
                    "type": "integer"
                },
                "nodesHealthy": {
                    "type": "integer"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: optional)` An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n"
                },
                "pluginProvider": {
                    "type": "string"
                },
                "pluginProviderVersion": {
                    "type": "string"
                },
                "schedulable": {
                    "type": "boolean"
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: optional)` An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                    "secret": true
                },
                "snapshotId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The external ID of a snapshot to restore. If ommited, the volume will be created from scratch. Conflicts with `clone_id`.\n"
                },
                "topologies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/ExternalVolumeTopology:ExternalVolumeTopology"
                    }
                },
                "topologyRequest": {
                    "$ref": "#/types/nomad:index/ExternalVolumeTopologyRequest:ExternalVolumeTopologyRequest",
                    "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n"
                },
                "type": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The type of the volume. Currently, only `csi` is supported.\n"
                },
                "volumeId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n"
                }
            },
            "required": [
                "capabilities",
                "controllerRequired",
                "controllersExpected",
                "controllersHealthy",
                "name",
                "nodesExpected",
                "nodesHealthy",
                "pluginId",
                "pluginProvider",
                "pluginProviderVersion",
                "schedulable",
                "topologies",
                "volumeId"
            ],
            "inputProperties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/ExternalVolumeCapability:ExternalVolumeCapability"
                    },
                    "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n",
                    "willReplaceOnChanges": true
                },
                "capacityMax": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a maximum volume size. This may not be supported by all storage providers.\n",
                    "willReplaceOnChanges": true
                },
                "capacityMin": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - Option to signal a minimum volume size. This may not be supported by all storage providers.\n",
                    "willReplaceOnChanges": true
                },
                "cloneId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The external ID of an existing volume to restore. If ommited, the volume will be created from scratch. Conflicts with `snapshot_id`.\n",
                    "willReplaceOnChanges": true
                },
                "mountOptions": {
                    "$ref": "#/types/nomad:index/ExternalVolumeMountOptions:ExternalVolumeMountOptions",
                    "description": "`(block: optional)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \"default\")` - The namespace in which to register the volume.\n",
                    "willReplaceOnChanges": true
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: optional)` An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n",
                    "willReplaceOnChanges": true
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: optional)` An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                    "secret": true
                },
                "snapshotId": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - The external ID of a snapshot to restore. If ommited, the volume will be created from scratch. Conflicts with `clone_id`.\n",
                    "willReplaceOnChanges": true
                },
                "topologyRequest": {
                    "$ref": "#/types/nomad:index/ExternalVolumeTopologyRequest:ExternalVolumeTopologyRequest",
                    "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The type of the volume. Currently, only `csi` is supported.\n",
                    "willReplaceOnChanges": true
                },
                "volumeId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "capabilities",
                "pluginId",
                "volumeId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalVolume resources.\n",
                "properties": {
                    "capabilities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/ExternalVolumeCapability:ExternalVolumeCapability"
                        },
                        "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "capacityMax": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Option to signal a maximum volume size. This may not be supported by all storage providers.\n",
                        "willReplaceOnChanges": true
                    },
                    "capacityMin": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Option to signal a minimum volume size. This may not be supported by all storage providers.\n",
                        "willReplaceOnChanges": true
                    },
                    "cloneId": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - The external ID of an existing volume to restore. If ommited, the volume will be created from scratch. Conflicts with `snapshot_id`.\n",
                        "willReplaceOnChanges": true
                    },
                    "controllerRequired": {
                        "type": "boolean"
                    },
                    "controllersExpected": {
                        "type": "integer"
                    },
                    "controllersHealthy": {
                        "type": "integer"
                    },
                    "mountOptions": {
                        "$ref": "#/types/nomad:index/ExternalVolumeMountOptions:ExternalVolumeMountOptions",
                        "description": "`(block: optional)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "`(string: \"default\")` - The namespace in which to register the volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodesExpected": {
                        "type": "integer"
                    },
                    "nodesHealthy": {
                        "type": "integer"
                    },
                    "parameters": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: optional)` An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                    },
                    "pluginId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "pluginProvider": {
                        "type": "string"
                    },
                    "pluginProviderVersion": {
                        "type": "string"
                    },
                    "schedulable": {
                        "type": "boolean"
                    },
                    "secrets": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: optional)` An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                        "secret": true
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - The external ID of a snapshot to restore. If ommited, the volume will be created from scratch. Conflicts with `clone_id`.\n",
                        "willReplaceOnChanges": true
                    },
                    "topologies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/ExternalVolumeTopology:ExternalVolumeTopology"
                        }
                    },
                    "topologyRequest": {
                        "$ref": "#/types/nomad:index/ExternalVolumeTopologyRequest:ExternalVolumeTopologyRequest",
                        "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The type of the volume. Currently, only `csi` is supported.\n",
                        "willReplaceOnChanges": true
                    },
                    "volumeId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/job:Job": {
            "properties": {
                "allocationIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs for allocations associated with this job.",
                    "deprecationMessage": "Retrieving allocation IDs from the job resource is deprecated and will be removed in a future release. Use the nomad.getAllocations data source instead."
                },
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The target datacenters for the job, as derived from the jobspec."
                },
                "deploymentId": {
                    "type": "string",
                    "description": "If detach = false, the ID for the deployment associated with the last job create/update, if one exists."
                },
                "deploymentStatus": {
                    "type": "string",
                    "description": "If detach = false, the status for the deployment associated with the last job create/update, if one exists."
                },
                "deregisterOnDestroy": {
                    "type": "boolean",
                    "description": "If true, the job will be deregistered on destroy."
                },
                "deregisterOnIdChange": {
                    "type": "boolean",
                    "description": "`(boolean: true)` - Determines if the job will be\nderegistered if the ID of the job in the jobspec changes.\n"
                },
                "detach": {
                    "type": "boolean",
                    "description": "`(boolean: true)` - If true, the provider will return immediately\nafter creating or updating, instead of monitoring.\n"
                },
                "hcl2": {
                    "$ref": "#/types/nomad:index/JobHcl2:JobHcl2",
                    "description": "`(block: optional)` - Options for the HCL2 jobspec parser.\n"
                },
                "jobspec": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The contents of the jobspec to register.\n"
                },
                "json": {
                    "type": "boolean",
                    "description": "`(boolean: false)` - Set this to `true` if your jobspec is structured with\nJSON instead of the default HCL.\n"
                },
                "modifyIndex": {
                    "type": "string",
                    "description": "Integer that increments for each change. Used to detect any changes between plan and apply."
                },
                "name": {
                    "type": "string",
                    "description": "The name of the job, as derived from the jobspec."
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace of the job, as derived from the jobspec."
                },
                "policyOverride": {
                    "type": "boolean",
                    "description": "`(boolean: false)` - Determines if the job will override any\nsoft-mandatory Sentinel policies and register even if they fail.\n"
                },
                "purgeOnDestroy": {
                    "type": "boolean",
                    "description": "`(boolean: false)` - Set this to true if you want the job to\nbe purged when the resource is destroyed.\n"
                },
                "readAllocationIds": {
                    "type": "boolean",
                    "deprecationMessage": "Retrieving allocation IDs from the job resource is deprecated and will be removed in a future release. Use the nomad.getAllocations data source instead."
                },
                "region": {
                    "type": "string",
                    "description": "The target region for the job, as derived from the jobspec."
                },
                "rerunIfDead": {
                    "type": "boolean",
                    "description": "`(boolean: false)` - Set this to true to force the job to run\nagain if its status is `dead`.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of the job."
                },
                "taskGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/JobTaskGroup:JobTaskGroup"
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The type of the job, as derived from the jobspec."
                }
            },
            "required": [
                "allocationIds",
                "datacenters",
                "deploymentId",
                "deploymentStatus",
                "jobspec",
                "modifyIndex",
                "name",
                "namespace",
                "region",
                "status",
                "taskGroups",
                "type"
            ],
            "inputProperties": {
                "deregisterOnDestroy": {
                    "type": "boolean",
                    "description": "If true, the job will be deregistered on destroy."
                },
                "deregisterOnIdChange": {
                    "type": "boolean",
                    "description": "`(boolean: true)` - Determines if the job will be\nderegistered if the ID of the job in the jobspec changes.\n"
                },
                "detach": {
                    "type": "boolean",
                    "description": "`(boolean: true)` - If true, the provider will return immediately\nafter creating or updating, instead of monitoring.\n"
                },
                "hcl2": {
                    "$ref": "#/types/nomad:index/JobHcl2:JobHcl2",
                    "description": "`(block: optional)` - Options for the HCL2 jobspec parser.\n"
                },
                "jobspec": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The contents of the jobspec to register.\n"
                },
                "json": {
                    "type": "boolean",
                    "description": "`(boolean: false)` - Set this to `true` if your jobspec is structured with\nJSON instead of the default HCL.\n"
                },
                "policyOverride": {
                    "type": "boolean",
                    "description": "`(boolean: false)` - Determines if the job will override any\nsoft-mandatory Sentinel policies and register even if they fail.\n"
                },
                "purgeOnDestroy": {
                    "type": "boolean",
                    "description": "`(boolean: false)` - Set this to true if you want the job to\nbe purged when the resource is destroyed.\n"
                },
                "readAllocationIds": {
                    "type": "boolean",
                    "deprecationMessage": "Retrieving allocation IDs from the job resource is deprecated and will be removed in a future release. Use the nomad.getAllocations data source instead."
                },
                "rerunIfDead": {
                    "type": "boolean",
                    "description": "`(boolean: false)` - Set this to true to force the job to run\nagain if its status is `dead`.\n"
                }
            },
            "requiredInputs": [
                "jobspec"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Job resources.\n",
                "properties": {
                    "allocationIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs for allocations associated with this job.",
                        "deprecationMessage": "Retrieving allocation IDs from the job resource is deprecated and will be removed in a future release. Use the nomad.getAllocations data source instead."
                    },
                    "datacenters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The target datacenters for the job, as derived from the jobspec."
                    },
                    "deploymentId": {
                        "type": "string",
                        "description": "If detach = false, the ID for the deployment associated with the last job create/update, if one exists."
                    },
                    "deploymentStatus": {
                        "type": "string",
                        "description": "If detach = false, the status for the deployment associated with the last job create/update, if one exists."
                    },
                    "deregisterOnDestroy": {
                        "type": "boolean",
                        "description": "If true, the job will be deregistered on destroy."
                    },
                    "deregisterOnIdChange": {
                        "type": "boolean",
                        "description": "`(boolean: true)` - Determines if the job will be\nderegistered if the ID of the job in the jobspec changes.\n"
                    },
                    "detach": {
                        "type": "boolean",
                        "description": "`(boolean: true)` - If true, the provider will return immediately\nafter creating or updating, instead of monitoring.\n"
                    },
                    "hcl2": {
                        "$ref": "#/types/nomad:index/JobHcl2:JobHcl2",
                        "description": "`(block: optional)` - Options for the HCL2 jobspec parser.\n"
                    },
                    "jobspec": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The contents of the jobspec to register.\n"
                    },
                    "json": {
                        "type": "boolean",
                        "description": "`(boolean: false)` - Set this to `true` if your jobspec is structured with\nJSON instead of the default HCL.\n"
                    },
                    "modifyIndex": {
                        "type": "string",
                        "description": "Integer that increments for each change. Used to detect any changes between plan and apply."
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the job, as derived from the jobspec."
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the job, as derived from the jobspec."
                    },
                    "policyOverride": {
                        "type": "boolean",
                        "description": "`(boolean: false)` - Determines if the job will override any\nsoft-mandatory Sentinel policies and register even if they fail.\n"
                    },
                    "purgeOnDestroy": {
                        "type": "boolean",
                        "description": "`(boolean: false)` - Set this to true if you want the job to\nbe purged when the resource is destroyed.\n"
                    },
                    "readAllocationIds": {
                        "type": "boolean",
                        "deprecationMessage": "Retrieving allocation IDs from the job resource is deprecated and will be removed in a future release. Use the nomad.getAllocations data source instead."
                    },
                    "region": {
                        "type": "string",
                        "description": "The target region for the job, as derived from the jobspec."
                    },
                    "rerunIfDead": {
                        "type": "boolean",
                        "description": "`(boolean: false)` - Set this to true to force the job to run\nagain if its status is `dead`.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the job."
                    },
                    "taskGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/JobTaskGroup:JobTaskGroup"
                        }
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the job, as derived from the jobspec."
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/namespace:Namespace": {
            "description": "Provisions a namespace within a Nomad cluster.\n\nNomad auto-generates a default namespace called `default`. This namespace\ncannot be removed, so destroying a `nomad.Namespace` resource where\n`name = \"default\"` will cause the namespace to be reset to its default\nconfiguration.\n\n## Example Usage\n\nRegistering a namespace:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst dev = new nomad.Namespace(\"dev\", {\n    name: \"dev\",\n    description: \"Shared development environment.\",\n    quota: \"dev\",\n    meta: {\n        owner: \"John Doe\",\n        foo: \"bar\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\ndev = nomad.Namespace(\"dev\",\n    name=\"dev\",\n    description=\"Shared development environment.\",\n    quota=\"dev\",\n    meta={\n        \"owner\": \"John Doe\",\n        \"foo\": \"bar\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dev = new Nomad.Namespace(\"dev\", new()\n    {\n        Name = \"dev\",\n        Description = \"Shared development environment.\",\n        Quota = \"dev\",\n        Meta = \n        {\n            { \"owner\", \"John Doe\" },\n            { \"foo\", \"bar\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewNamespace(ctx, \"dev\", \u0026nomad.NamespaceArgs{\n\t\t\tName:        pulumi.String(\"dev\"),\n\t\t\tDescription: pulumi.String(\"Shared development environment.\"),\n\t\t\tQuota:       pulumi.String(\"dev\"),\n\t\t\tMeta: pulumi.StringMap{\n\t\t\t\t\"owner\": pulumi.String(\"John Doe\"),\n\t\t\t\t\"foo\":   pulumi.String(\"bar\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.Namespace;\nimport com.pulumi.nomad.NamespaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dev = new Namespace(\"dev\", NamespaceArgs.builder()\n            .name(\"dev\")\n            .description(\"Shared development environment.\")\n            .quota(\"dev\")\n            .meta(Map.ofEntries(\n                Map.entry(\"owner\", \"John Doe\"),\n                Map.entry(\"foo\", \"bar\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dev:\n    type: nomad:Namespace\n    properties:\n      name: dev\n      description: Shared development environment.\n      quota: dev\n      meta:\n        owner: John Doe\n        foo: bar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nRegistering a namespace with a quota:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst webTeam = new nomad.QuoteSpecification(\"web_team\", {\n    name: \"web-team\",\n    description: \"web team quota\",\n    limits: [{\n        region: \"global\",\n        regionLimit: {\n            cpu: 1000,\n            memoryMb: 256,\n        },\n    }],\n});\nconst web = new nomad.Namespace(\"web\", {\n    name: \"web\",\n    description: \"Web team production environment.\",\n    quota: webTeam.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nweb_team = nomad.QuoteSpecification(\"web_team\",\n    name=\"web-team\",\n    description=\"web team quota\",\n    limits=[{\n        \"region\": \"global\",\n        \"region_limit\": {\n            \"cpu\": 1000,\n            \"memory_mb\": 256,\n        },\n    }])\nweb = nomad.Namespace(\"web\",\n    name=\"web\",\n    description=\"Web team production environment.\",\n    quota=web_team.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var webTeam = new Nomad.QuoteSpecification(\"web_team\", new()\n    {\n        Name = \"web-team\",\n        Description = \"web team quota\",\n        Limits = new[]\n        {\n            new Nomad.Inputs.QuoteSpecificationLimitArgs\n            {\n                Region = \"global\",\n                RegionLimit = new Nomad.Inputs.QuoteSpecificationLimitRegionLimitArgs\n                {\n                    Cpu = 1000,\n                    MemoryMb = 256,\n                },\n            },\n        },\n    });\n\n    var web = new Nomad.Namespace(\"web\", new()\n    {\n        Name = \"web\",\n        Description = \"Web team production environment.\",\n        Quota = webTeam.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\twebTeam, err := nomad.NewQuoteSpecification(ctx, \"web_team\", \u0026nomad.QuoteSpecificationArgs{\n\t\t\tName:        pulumi.String(\"web-team\"),\n\t\t\tDescription: pulumi.String(\"web team quota\"),\n\t\t\tLimits: nomad.QuoteSpecificationLimitArray{\n\t\t\t\t\u0026nomad.QuoteSpecificationLimitArgs{\n\t\t\t\t\tRegion: pulumi.String(\"global\"),\n\t\t\t\t\tRegionLimit: \u0026nomad.QuoteSpecificationLimitRegionLimitArgs{\n\t\t\t\t\t\tCpu:      pulumi.Int(1000),\n\t\t\t\t\t\tMemoryMb: pulumi.Int(256),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = nomad.NewNamespace(ctx, \"web\", \u0026nomad.NamespaceArgs{\n\t\t\tName:        pulumi.String(\"web\"),\n\t\t\tDescription: pulumi.String(\"Web team production environment.\"),\n\t\t\tQuota:       webTeam.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.QuoteSpecification;\nimport com.pulumi.nomad.QuoteSpecificationArgs;\nimport com.pulumi.nomad.inputs.QuoteSpecificationLimitArgs;\nimport com.pulumi.nomad.inputs.QuoteSpecificationLimitRegionLimitArgs;\nimport com.pulumi.nomad.Namespace;\nimport com.pulumi.nomad.NamespaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var webTeam = new QuoteSpecification(\"webTeam\", QuoteSpecificationArgs.builder()\n            .name(\"web-team\")\n            .description(\"web team quota\")\n            .limits(QuoteSpecificationLimitArgs.builder()\n                .region(\"global\")\n                .regionLimit(QuoteSpecificationLimitRegionLimitArgs.builder()\n                    .cpu(1000)\n                    .memoryMb(256)\n                    .build())\n                .build())\n            .build());\n\n        var web = new Namespace(\"web\", NamespaceArgs.builder()\n            .name(\"web\")\n            .description(\"Web team production environment.\")\n            .quota(webTeam.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  webTeam:\n    type: nomad:QuoteSpecification\n    name: web_team\n    properties:\n      name: web-team\n      description: web team quota\n      limits:\n        - region: global\n          regionLimit:\n            cpu: 1000\n            memoryMb: 256\n  web:\n    type: nomad:Namespace\n    properties:\n      name: web\n      description: Web team production environment.\n      quota: ${webTeam.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "capabilities": {
                    "$ref": "#/types/nomad:index/NamespaceCapabilities:NamespaceCapabilities",
                    "description": "`(block: \u003coptional\u003e)` - A block of capabilities for the namespace. Can't\nbe repeated. See below for the structure of this block.\n"
                },
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - A description of the namespace.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` -  Specifies arbitrary KV metadata to associate with the namespace.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A unique name for the namespace.\n"
                },
                "nodePoolConfig": {
                    "$ref": "#/types/nomad:index/NamespaceNodePoolConfig:NamespaceNodePoolConfig",
                    "description": "`(block: \u003coptional\u003e)` - A block with node pool configuration for the namespace (Nomad Enterprise only).\n"
                },
                "quota": {
                    "type": "string",
                    "description": "`(string: \"\")` - A resource quota to attach to the namespace.\n"
                }
            },
            "required": [
                "name",
                "nodePoolConfig"
            ],
            "inputProperties": {
                "capabilities": {
                    "$ref": "#/types/nomad:index/NamespaceCapabilities:NamespaceCapabilities",
                    "description": "`(block: \u003coptional\u003e)` - A block of capabilities for the namespace. Can't\nbe repeated. See below for the structure of this block.\n"
                },
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - A description of the namespace.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` -  Specifies arbitrary KV metadata to associate with the namespace.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A unique name for the namespace.\n",
                    "willReplaceOnChanges": true
                },
                "nodePoolConfig": {
                    "$ref": "#/types/nomad:index/NamespaceNodePoolConfig:NamespaceNodePoolConfig",
                    "description": "`(block: \u003coptional\u003e)` - A block with node pool configuration for the namespace (Nomad Enterprise only).\n"
                },
                "quota": {
                    "type": "string",
                    "description": "`(string: \"\")` - A resource quota to attach to the namespace.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Namespace resources.\n",
                "properties": {
                    "capabilities": {
                        "$ref": "#/types/nomad:index/NamespaceCapabilities:NamespaceCapabilities",
                        "description": "`(block: \u003coptional\u003e)` - A block of capabilities for the namespace. Can't\nbe repeated. See below for the structure of this block.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "`(string: \"\")` - A description of the namespace.\n"
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: \u003coptional\u003e)` -  Specifies arbitrary KV metadata to associate with the namespace.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - A unique name for the namespace.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodePoolConfig": {
                        "$ref": "#/types/nomad:index/NamespaceNodePoolConfig:NamespaceNodePoolConfig",
                        "description": "`(block: \u003coptional\u003e)` - A block with node pool configuration for the namespace (Nomad Enterprise only).\n"
                    },
                    "quota": {
                        "type": "string",
                        "description": "`(string: \"\")` - A resource quota to attach to the namespace.\n"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/nodePool:NodePool": {
            "description": "Provisions a node pool within a Nomad cluster.\n\n## Example Usage\n\nRegistering a node pool:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst dev = new nomad.NodePool(\"dev\", {\n    name: \"dev\",\n    description: \"Nodes for the development environment.\",\n    meta: {\n        department: \"Engineering\",\n        env: \"dev\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\ndev = nomad.NodePool(\"dev\",\n    name=\"dev\",\n    description=\"Nodes for the development environment.\",\n    meta={\n        \"department\": \"Engineering\",\n        \"env\": \"dev\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dev = new Nomad.NodePool(\"dev\", new()\n    {\n        Name = \"dev\",\n        Description = \"Nodes for the development environment.\",\n        Meta = \n        {\n            { \"department\", \"Engineering\" },\n            { \"env\", \"dev\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewNodePool(ctx, \"dev\", \u0026nomad.NodePoolArgs{\n\t\t\tName:        pulumi.String(\"dev\"),\n\t\t\tDescription: pulumi.String(\"Nodes for the development environment.\"),\n\t\t\tMeta: pulumi.StringMap{\n\t\t\t\t\"department\": pulumi.String(\"Engineering\"),\n\t\t\t\t\"env\":        pulumi.String(\"dev\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NodePool;\nimport com.pulumi.nomad.NodePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dev = new NodePool(\"dev\", NodePoolArgs.builder()\n            .name(\"dev\")\n            .description(\"Nodes for the development environment.\")\n            .meta(Map.ofEntries(\n                Map.entry(\"department\", \"Engineering\"),\n                Map.entry(\"env\", \"dev\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dev:\n    type: nomad:NodePool\n    properties:\n      name: dev\n      description: Nodes for the development environment.\n      meta:\n        department: Engineering\n        env: dev\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "`(string)` - The description of the node pool.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string)` - Arbitrary KV metadata associated with the\nnode pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string)` - The name of the node pool.\n"
                },
                "schedulerConfig": {
                    "$ref": "#/types/nomad:index/NodePoolSchedulerConfig:NodePoolSchedulerConfig",
                    "description": "`(block)` - Scheduler configuration for the node pool.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "`(string)` - The description of the node pool.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string)` - Arbitrary KV metadata associated with the\nnode pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string)` - The name of the node pool.\n",
                    "willReplaceOnChanges": true
                },
                "schedulerConfig": {
                    "$ref": "#/types/nomad:index/NodePoolSchedulerConfig:NodePoolSchedulerConfig",
                    "description": "`(block)` - Scheduler configuration for the node pool.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NodePool resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "`(string)` - The description of the node pool.\n"
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string)` - Arbitrary KV metadata associated with the\nnode pool.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string)` - The name of the node pool.\n",
                        "willReplaceOnChanges": true
                    },
                    "schedulerConfig": {
                        "$ref": "#/types/nomad:index/NodePoolSchedulerConfig:NodePoolSchedulerConfig",
                        "description": "`(block)` - Scheduler configuration for the node pool.\n"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/quoteSpecification:QuoteSpecification": {
            "description": "Manages a quota specification in a Nomad cluster.\n\n## Example Usage\n\nRegistering a quota specification:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst prodApi = new nomad.QuoteSpecification(\"prod_api\", {\n    name: \"prod-api\",\n    description: \"Production instances of backend API servers\",\n    limits: [{\n        region: \"global\",\n        regionLimit: {\n            cpu: 2400,\n            memoryMb: 1200,\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nprod_api = nomad.QuoteSpecification(\"prod_api\",\n    name=\"prod-api\",\n    description=\"Production instances of backend API servers\",\n    limits=[{\n        \"region\": \"global\",\n        \"region_limit\": {\n            \"cpu\": 2400,\n            \"memory_mb\": 1200,\n        },\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodApi = new Nomad.QuoteSpecification(\"prod_api\", new()\n    {\n        Name = \"prod-api\",\n        Description = \"Production instances of backend API servers\",\n        Limits = new[]\n        {\n            new Nomad.Inputs.QuoteSpecificationLimitArgs\n            {\n                Region = \"global\",\n                RegionLimit = new Nomad.Inputs.QuoteSpecificationLimitRegionLimitArgs\n                {\n                    Cpu = 2400,\n                    MemoryMb = 1200,\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewQuoteSpecification(ctx, \"prod_api\", \u0026nomad.QuoteSpecificationArgs{\n\t\t\tName:        pulumi.String(\"prod-api\"),\n\t\t\tDescription: pulumi.String(\"Production instances of backend API servers\"),\n\t\t\tLimits: nomad.QuoteSpecificationLimitArray{\n\t\t\t\t\u0026nomad.QuoteSpecificationLimitArgs{\n\t\t\t\t\tRegion: pulumi.String(\"global\"),\n\t\t\t\t\tRegionLimit: \u0026nomad.QuoteSpecificationLimitRegionLimitArgs{\n\t\t\t\t\t\tCpu:      pulumi.Int(2400),\n\t\t\t\t\t\tMemoryMb: pulumi.Int(1200),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.QuoteSpecification;\nimport com.pulumi.nomad.QuoteSpecificationArgs;\nimport com.pulumi.nomad.inputs.QuoteSpecificationLimitArgs;\nimport com.pulumi.nomad.inputs.QuoteSpecificationLimitRegionLimitArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var prodApi = new QuoteSpecification(\"prodApi\", QuoteSpecificationArgs.builder()\n            .name(\"prod-api\")\n            .description(\"Production instances of backend API servers\")\n            .limits(QuoteSpecificationLimitArgs.builder()\n                .region(\"global\")\n                .regionLimit(QuoteSpecificationLimitRegionLimitArgs.builder()\n                    .cpu(2400)\n                    .memoryMb(1200)\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodApi:\n    type: nomad:QuoteSpecification\n    name: prod_api\n    properties:\n      name: prod-api\n      description: Production instances of backend API servers\n      limits:\n        - region: global\n          regionLimit:\n            cpu: 2400\n            memoryMb: 1200\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - A description of the quota specification.\n"
                },
                "limits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/QuoteSpecificationLimit:QuoteSpecificationLimit"
                    },
                    "description": "`(block: \u003crequired\u003e)` - A block of quota limits to enforce. Can\nbe repeated. See below for the structure of this block.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A unique name for the quota specification.\n"
                }
            },
            "required": [
                "limits",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - A description of the quota specification.\n"
                },
                "limits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/QuoteSpecificationLimit:QuoteSpecificationLimit"
                    },
                    "description": "`(block: \u003crequired\u003e)` - A block of quota limits to enforce. Can\nbe repeated. See below for the structure of this block.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A unique name for the quota specification.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "limits"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QuoteSpecification resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "`(string: \"\")` - A description of the quota specification.\n"
                    },
                    "limits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/QuoteSpecificationLimit:QuoteSpecificationLimit"
                        },
                        "description": "`(block: \u003crequired\u003e)` - A block of quota limits to enforce. Can\nbe repeated. See below for the structure of this block.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - A unique name for the quota specification.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/schedulerConfig:SchedulerConfig": {
            "description": "Manages scheduler configuration of the Nomad cluster.\n\n\u003e **Warning:** destroying this resource will not have any effect in the\ncluster configuration, since there's no clear definition of what a destroy\naction should do. The cluster will be left as-is and only the state reference\nwill be removed.\n\n## Example Usage\n\nSet cluster scheduler configuration:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst config = new nomad.SchedulerConfig(\"config\", {\n    schedulerAlgorithm: \"spread\",\n    memoryOversubscriptionEnabled: true,\n    preemptionConfig: {\n        system_scheduler_enabled: true,\n        batch_scheduler_enabled: true,\n        service_scheduler_enabled: true,\n        sysbatch_scheduler_enabled: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nconfig = nomad.SchedulerConfig(\"config\",\n    scheduler_algorithm=\"spread\",\n    memory_oversubscription_enabled=True,\n    preemption_config={\n        \"system_scheduler_enabled\": True,\n        \"batch_scheduler_enabled\": True,\n        \"service_scheduler_enabled\": True,\n        \"sysbatch_scheduler_enabled\": True,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Nomad.SchedulerConfig(\"config\", new()\n    {\n        SchedulerAlgorithm = \"spread\",\n        MemoryOversubscriptionEnabled = true,\n        PreemptionConfig = \n        {\n            { \"system_scheduler_enabled\", true },\n            { \"batch_scheduler_enabled\", true },\n            { \"service_scheduler_enabled\", true },\n            { \"sysbatch_scheduler_enabled\", true },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewSchedulerConfig(ctx, \"config\", \u0026nomad.SchedulerConfigArgs{\n\t\t\tSchedulerAlgorithm:            pulumi.String(\"spread\"),\n\t\t\tMemoryOversubscriptionEnabled: pulumi.Bool(true),\n\t\t\tPreemptionConfig: pulumi.BoolMap{\n\t\t\t\t\"system_scheduler_enabled\":   pulumi.Bool(true),\n\t\t\t\t\"batch_scheduler_enabled\":    pulumi.Bool(true),\n\t\t\t\t\"service_scheduler_enabled\":  pulumi.Bool(true),\n\t\t\t\t\"sysbatch_scheduler_enabled\": pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.SchedulerConfig;\nimport com.pulumi.nomad.SchedulerConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SchedulerConfig(\"config\", SchedulerConfigArgs.builder()\n            .schedulerAlgorithm(\"spread\")\n            .memoryOversubscriptionEnabled(true)\n            .preemptionConfig(Map.ofEntries(\n                Map.entry(\"system_scheduler_enabled\", true),\n                Map.entry(\"batch_scheduler_enabled\", true),\n                Map.entry(\"service_scheduler_enabled\", true),\n                Map.entry(\"sysbatch_scheduler_enabled\", true)\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: nomad:SchedulerConfig\n    properties:\n      schedulerAlgorithm: spread\n      memoryOversubscriptionEnabled: true\n      preemptionConfig:\n        system_scheduler_enabled: true\n        batch_scheduler_enabled: true\n        service_scheduler_enabled: true\n        sysbatch_scheduler_enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "memoryOversubscriptionEnabled": {
                    "type": "boolean",
                    "description": "`(bool: false)` - When `true`, tasks may exceed their reserved memory limit.\n"
                },
                "preemptionConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "boolean"
                    },
                    "description": "`(map[string]bool)` - Options to enable preemption for various schedulers.\n"
                },
                "schedulerAlgorithm": {
                    "type": "string",
                    "description": "`(string: \"binpack\")` - Specifies whether scheduler binpacks or spreads allocations on available nodes. Possible values are `binpack` and `spread`.\n"
                }
            },
            "inputProperties": {
                "memoryOversubscriptionEnabled": {
                    "type": "boolean",
                    "description": "`(bool: false)` - When `true`, tasks may exceed their reserved memory limit.\n"
                },
                "preemptionConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "boolean"
                    },
                    "description": "`(map[string]bool)` - Options to enable preemption for various schedulers.\n"
                },
                "schedulerAlgorithm": {
                    "type": "string",
                    "description": "`(string: \"binpack\")` - Specifies whether scheduler binpacks or spreads allocations on available nodes. Possible values are `binpack` and `spread`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SchedulerConfig resources.\n",
                "properties": {
                    "memoryOversubscriptionEnabled": {
                        "type": "boolean",
                        "description": "`(bool: false)` - When `true`, tasks may exceed their reserved memory limit.\n"
                    },
                    "preemptionConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "boolean"
                        },
                        "description": "`(map[string]bool)` - Options to enable preemption for various schedulers.\n"
                    },
                    "schedulerAlgorithm": {
                        "type": "string",
                        "description": "`(string: \"binpack\")` - Specifies whether scheduler binpacks or spreads allocations on available nodes. Possible values are `binpack` and `spread`.\n"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/sentinelPolicy:SentinelPolicy": {
            "description": "Manages a Sentinel policy registered in Nomad.\n\n\u003e **Enterprise Only!** This API endpoint and functionality only exists in\n   Nomad Enterprise. This is not present in the open source version of Nomad.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst exec_only = new nomad.SentinelPolicy(\"exec-only\", {\n    name: \"exec-only\",\n    description: \"Only allow jobs that are based on an exec driver.\",\n    policy: `main = rule { all_drivers_exec }\n\n# all_drivers_exec checks that all the drivers in use are exec\nall_drivers_exec = rule {\n    all job.task_groups as tg {\n        all tg.tasks as task {\n            task.driver is \"exec\"\n        }\n    }\n}\n`,\n    scope: \"submit-job\",\n    enforcementLevel: \"soft-mandatory\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexec_only = nomad.SentinelPolicy(\"exec-only\",\n    name=\"exec-only\",\n    description=\"Only allow jobs that are based on an exec driver.\",\n    policy=\"\"\"main = rule { all_drivers_exec }\n\n# all_drivers_exec checks that all the drivers in use are exec\nall_drivers_exec = rule {\n    all job.task_groups as tg {\n        all tg.tasks as task {\n            task.driver is \"exec\"\n        }\n    }\n}\n\"\"\",\n    scope=\"submit-job\",\n    enforcement_level=\"soft-mandatory\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exec_only = new Nomad.SentinelPolicy(\"exec-only\", new()\n    {\n        Name = \"exec-only\",\n        Description = \"Only allow jobs that are based on an exec driver.\",\n        Policy = @\"main = rule { all_drivers_exec }\n\n# all_drivers_exec checks that all the drivers in use are exec\nall_drivers_exec = rule {\n    all job.task_groups as tg {\n        all tg.tasks as task {\n            task.driver is \"\"exec\"\"\n        }\n    }\n}\n\",\n        Scope = \"submit-job\",\n        EnforcementLevel = \"soft-mandatory\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewSentinelPolicy(ctx, \"exec-only\", \u0026nomad.SentinelPolicyArgs{\n\t\t\tName:        pulumi.String(\"exec-only\"),\n\t\t\tDescription: pulumi.String(\"Only allow jobs that are based on an exec driver.\"),\n\t\t\tPolicy: pulumi.String(`main = rule { all_drivers_exec }\n\n# all_drivers_exec checks that all the drivers in use are exec\nall_drivers_exec = rule {\n    all job.task_groups as tg {\n        all tg.tasks as task {\n            task.driver is \"exec\"\n        }\n    }\n}\n`),\n\t\t\tScope:            pulumi.String(\"submit-job\"),\n\t\t\tEnforcementLevel: pulumi.String(\"soft-mandatory\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.SentinelPolicy;\nimport com.pulumi.nomad.SentinelPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exec_only = new SentinelPolicy(\"exec-only\", SentinelPolicyArgs.builder()\n            .name(\"exec-only\")\n            .description(\"Only allow jobs that are based on an exec driver.\")\n            .policy(\"\"\"\nmain = rule { all_drivers_exec }\n\n# all_drivers_exec checks that all the drivers in use are exec\nall_drivers_exec = rule {\n    all job.task_groups as tg {\n        all tg.tasks as task {\n            task.driver is \"exec\"\n        }\n    }\n}\n            \"\"\")\n            .scope(\"submit-job\")\n            .enforcementLevel(\"soft-mandatory\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exec-only:\n    type: nomad:SentinelPolicy\n    properties:\n      name: exec-only\n      description: Only allow jobs that are based on an exec driver.\n      policy: |\n        main = rule { all_drivers_exec }\n\n        # all_drivers_exec checks that all the drivers in use are exec\n        all_drivers_exec = rule {\n            all job.task_groups as tg {\n                all tg.tasks as task {\n                    task.driver is \"exec\"\n                }\n            }\n        }\n      scope: submit-job\n      enforcementLevel: soft-mandatory\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - A description of the policy.\n\n[scope]: https://www.nomadproject.io/guides/sentinel-policy.html#policy-scope\n[enforcement-level]: https://www.nomadproject.io/guides/sentinel-policy.html#enforcement-level\n"
                },
                "enforcementLevel": {
                    "type": "string",
                    "description": "`(strings: \u003crequired\u003e)` - The [enforcement level][enforcement-level]\nfor this policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A unique name for the policy.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The contents of the policy to register.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "`(strings: \u003crequired\u003e)` - The [scope][scope] for this policy.\n"
                }
            },
            "required": [
                "enforcementLevel",
                "name",
                "policy",
                "scope"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "`(string: \"\")` - A description of the policy.\n\n[scope]: https://www.nomadproject.io/guides/sentinel-policy.html#policy-scope\n[enforcement-level]: https://www.nomadproject.io/guides/sentinel-policy.html#enforcement-level\n"
                },
                "enforcementLevel": {
                    "type": "string",
                    "description": "`(strings: \u003crequired\u003e)` - The [enforcement level][enforcement-level]\nfor this policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A unique name for the policy.\n",
                    "willReplaceOnChanges": true
                },
                "policy": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The contents of the policy to register.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "`(strings: \u003crequired\u003e)` - The [scope][scope] for this policy.\n"
                }
            },
            "requiredInputs": [
                "enforcementLevel",
                "policy",
                "scope"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SentinelPolicy resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "`(string: \"\")` - A description of the policy.\n\n[scope]: https://www.nomadproject.io/guides/sentinel-policy.html#policy-scope\n[enforcement-level]: https://www.nomadproject.io/guides/sentinel-policy.html#enforcement-level\n"
                    },
                    "enforcementLevel": {
                        "type": "string",
                        "description": "`(strings: \u003crequired\u003e)` - The [enforcement level][enforcement-level]\nfor this policy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - A unique name for the policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "policy": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The contents of the policy to register.\n"
                    },
                    "scope": {
                        "type": "string",
                        "description": "`(strings: \u003crequired\u003e)` - The [scope][scope] for this policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/variable:Variable": {
            "description": "## Example Usage\n\nCreating a variable in the default namespace:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = new nomad.Variable(\"example\", {\n    path: \"some/path/of/your/choosing\",\n    items: {\n        example_key: \"example_value\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.Variable(\"example\",\n    path=\"some/path/of/your/choosing\",\n    items={\n        \"example_key\": \"example_value\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Nomad.Variable(\"example\", new()\n    {\n        Path = \"some/path/of/your/choosing\",\n        Items = \n        {\n            { \"example_key\", \"example_value\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewVariable(ctx, \"example\", \u0026nomad.VariableArgs{\n\t\t\tPath: pulumi.String(\"some/path/of/your/choosing\"),\n\t\t\tItems: pulumi.StringMap{\n\t\t\t\t\"example_key\": pulumi.String(\"example_value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.Variable;\nimport com.pulumi.nomad.VariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Variable(\"example\", VariableArgs.builder()\n            .path(\"some/path/of/your/choosing\")\n            .items(Map.of(\"example_key\", \"example_value\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: nomad:Variable\n    properties:\n      path: some/path/of/your/choosing\n      items:\n        example_key: example_value\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nCreating a variable in a custom namespace:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = new nomad.Namespace(\"example\", {\n    name: \"example\",\n    description: \"Example namespace.\",\n});\nconst exampleVariable = new nomad.Variable(\"example\", {\n    path: \"some/path/of/your/choosing\",\n    namespace: example.name,\n    items: {\n        example_key: \"example_value\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.Namespace(\"example\",\n    name=\"example\",\n    description=\"Example namespace.\")\nexample_variable = nomad.Variable(\"example\",\n    path=\"some/path/of/your/choosing\",\n    namespace=example.name,\n    items={\n        \"example_key\": \"example_value\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Nomad.Namespace(\"example\", new()\n    {\n        Name = \"example\",\n        Description = \"Example namespace.\",\n    });\n\n    var exampleVariable = new Nomad.Variable(\"example\", new()\n    {\n        Path = \"some/path/of/your/choosing\",\n        Namespace = example.Name,\n        Items = \n        {\n            { \"example_key\", \"example_value\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := nomad.NewNamespace(ctx, \"example\", \u0026nomad.NamespaceArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"Example namespace.\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = nomad.NewVariable(ctx, \"example\", \u0026nomad.VariableArgs{\n\t\t\tPath:      pulumi.String(\"some/path/of/your/choosing\"),\n\t\t\tNamespace: example.Name,\n\t\t\tItems: pulumi.StringMap{\n\t\t\t\t\"example_key\": pulumi.String(\"example_value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.Namespace;\nimport com.pulumi.nomad.NamespaceArgs;\nimport com.pulumi.nomad.Variable;\nimport com.pulumi.nomad.VariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Namespace(\"example\", NamespaceArgs.builder()\n            .name(\"example\")\n            .description(\"Example namespace.\")\n            .build());\n\n        var exampleVariable = new Variable(\"exampleVariable\", VariableArgs.builder()\n            .path(\"some/path/of/your/choosing\")\n            .namespace(example.name())\n            .items(Map.of(\"example_key\", \"example_value\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: nomad:Namespace\n    properties:\n      name: example\n      description: Example namespace.\n  exampleVariable:\n    type: nomad:Variable\n    name: example\n    properties:\n      path: some/path/of/your/choosing\n      namespace: ${example.name}\n      items:\n        example_key: example_value\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "items": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003crequired\u003e)` - An arbitrary map of items to create in the variable.\n",
                    "secret": true
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \"default\")` - The namepsace to create the variable in.\n"
                },
                "path": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A unique path to create the variable at.\n"
                }
            },
            "required": [
                "items",
                "path"
            ],
            "inputProperties": {
                "items": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003crequired\u003e)` - An arbitrary map of items to create in the variable.\n",
                    "secret": true
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \"default\")` - The namepsace to create the variable in.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A unique path to create the variable at.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "items",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Variable resources.\n",
                "properties": {
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: \u003crequired\u003e)` - An arbitrary map of items to create in the variable.\n",
                        "secret": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "`(string: \"default\")` - The namepsace to create the variable in.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - A unique path to create the variable at.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "nomad:index/volume:Volume": {
            "description": "## Example Usage\n\nRegistering a volume:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\n// It can sometimes be helpful to wait for a particular plugin to be available\nconst ebs = nomad.getPlugin({\n    pluginId: \"aws-ebs0\",\n    waitForHealthy: true,\n});\nconst mysqlVolume = new nomad.Volume(\"mysql_volume\", {\n    type: \"csi\",\n    pluginId: \"aws-ebs0\",\n    volumeId: \"mysql_volume\",\n    name: \"mysql_volume\",\n    externalId: hashistack.ebsTestVolumeId,\n    capabilities: [{\n        accessMode: \"single-node-writer\",\n        attachmentMode: \"file-system\",\n    }],\n    mountOptions: {\n        fsType: \"ext4\",\n    },\n    topologyRequest: {\n        required: {\n            topologies: [\n                {\n                    segments: {\n                        rack: \"R1\",\n                        zone: \"us-east-1a\",\n                    },\n                },\n                {\n                    segments: {\n                        rack: \"R2\",\n                    },\n                },\n            ],\n        },\n    },\n}, {\n    dependsOn: [ebs],\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\n# It can sometimes be helpful to wait for a particular plugin to be available\nebs = nomad.get_plugin(plugin_id=\"aws-ebs0\",\n    wait_for_healthy=True)\nmysql_volume = nomad.Volume(\"mysql_volume\",\n    type=\"csi\",\n    plugin_id=\"aws-ebs0\",\n    volume_id=\"mysql_volume\",\n    name=\"mysql_volume\",\n    external_id=hashistack[\"ebsTestVolumeId\"],\n    capabilities=[{\n        \"access_mode\": \"single-node-writer\",\n        \"attachment_mode\": \"file-system\",\n    }],\n    mount_options={\n        \"fs_type\": \"ext4\",\n    },\n    topology_request={\n        \"required\": {\n            \"topologies\": [\n                {\n                    \"segments\": {\n                        \"rack\": \"R1\",\n                        \"zone\": \"us-east-1a\",\n                    },\n                },\n                {\n                    \"segments\": {\n                        \"rack\": \"R2\",\n                    },\n                },\n            ],\n        },\n    },\n    opts = pulumi.ResourceOptions(depends_on=[ebs]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // It can sometimes be helpful to wait for a particular plugin to be available\n    var ebs = Nomad.GetPlugin.Invoke(new()\n    {\n        PluginId = \"aws-ebs0\",\n        WaitForHealthy = true,\n    });\n\n    var mysqlVolume = new Nomad.Volume(\"mysql_volume\", new()\n    {\n        Type = \"csi\",\n        PluginId = \"aws-ebs0\",\n        VolumeId = \"mysql_volume\",\n        Name = \"mysql_volume\",\n        ExternalId = hashistack.EbsTestVolumeId,\n        Capabilities = new[]\n        {\n            new Nomad.Inputs.VolumeCapabilityArgs\n            {\n                AccessMode = \"single-node-writer\",\n                AttachmentMode = \"file-system\",\n            },\n        },\n        MountOptions = new Nomad.Inputs.VolumeMountOptionsArgs\n        {\n            FsType = \"ext4\",\n        },\n        TopologyRequest = new Nomad.Inputs.VolumeTopologyRequestArgs\n        {\n            Required = new Nomad.Inputs.VolumeTopologyRequestRequiredArgs\n            {\n                Topologies = new[]\n                {\n                    new Nomad.Inputs.VolumeTopologyRequestRequiredTopologyArgs\n                    {\n                        Segments = \n                        {\n                            { \"rack\", \"R1\" },\n                            { \"zone\", \"us-east-1a\" },\n                        },\n                    },\n                    new Nomad.Inputs.VolumeTopologyRequestRequiredTopologyArgs\n                    {\n                        Segments = \n                        {\n                            { \"rack\", \"R2\" },\n                        },\n                    },\n                },\n            },\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            ebs,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// It can sometimes be helpful to wait for a particular plugin to be available\n\t\tebs, err := nomad.GetPlugin(ctx, \u0026nomad.GetPluginArgs{\n\t\t\tPluginId:       \"aws-ebs0\",\n\t\t\tWaitForHealthy: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = nomad.NewVolume(ctx, \"mysql_volume\", \u0026nomad.VolumeArgs{\n\t\t\tType:       pulumi.String(\"csi\"),\n\t\t\tPluginId:   pulumi.String(\"aws-ebs0\"),\n\t\t\tVolumeId:   pulumi.String(\"mysql_volume\"),\n\t\t\tName:       pulumi.String(\"mysql_volume\"),\n\t\t\tExternalId: pulumi.Any(hashistack.EbsTestVolumeId),\n\t\t\tCapabilities: nomad.VolumeCapabilityArray{\n\t\t\t\t\u0026nomad.VolumeCapabilityArgs{\n\t\t\t\t\tAccessMode:     pulumi.String(\"single-node-writer\"),\n\t\t\t\t\tAttachmentMode: pulumi.String(\"file-system\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMountOptions: \u0026nomad.VolumeMountOptionsArgs{\n\t\t\t\tFsType: pulumi.String(\"ext4\"),\n\t\t\t},\n\t\t\tTopologyRequest: \u0026nomad.VolumeTopologyRequestArgs{\n\t\t\t\tRequired: \u0026nomad.VolumeTopologyRequestRequiredArgs{\n\t\t\t\t\tTopologies: nomad.VolumeTopologyRequestRequiredTopologyArray{\n\t\t\t\t\t\t\u0026nomad.VolumeTopologyRequestRequiredTopologyArgs{\n\t\t\t\t\t\t\tSegments: pulumi.StringMap{\n\t\t\t\t\t\t\t\t\"rack\": pulumi.String(\"R1\"),\n\t\t\t\t\t\t\t\t\"zone\": pulumi.String(\"us-east-1a\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026nomad.VolumeTopologyRequestRequiredTopologyArgs{\n\t\t\t\t\t\t\tSegments: pulumi.StringMap{\n\t\t\t\t\t\t\t\t\"rack\": pulumi.String(\"R2\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tebs,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetPluginArgs;\nimport com.pulumi.nomad.Volume;\nimport com.pulumi.nomad.VolumeArgs;\nimport com.pulumi.nomad.inputs.VolumeCapabilityArgs;\nimport com.pulumi.nomad.inputs.VolumeMountOptionsArgs;\nimport com.pulumi.nomad.inputs.VolumeTopologyRequestArgs;\nimport com.pulumi.nomad.inputs.VolumeTopologyRequestRequiredArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // It can sometimes be helpful to wait for a particular plugin to be available\n        final var ebs = NomadFunctions.getPlugin(GetPluginArgs.builder()\n            .pluginId(\"aws-ebs0\")\n            .waitForHealthy(true)\n            .build());\n\n        var mysqlVolume = new Volume(\"mysqlVolume\", VolumeArgs.builder()\n            .type(\"csi\")\n            .pluginId(\"aws-ebs0\")\n            .volumeId(\"mysql_volume\")\n            .name(\"mysql_volume\")\n            .externalId(hashistack.ebsTestVolumeId())\n            .capabilities(VolumeCapabilityArgs.builder()\n                .accessMode(\"single-node-writer\")\n                .attachmentMode(\"file-system\")\n                .build())\n            .mountOptions(VolumeMountOptionsArgs.builder()\n                .fsType(\"ext4\")\n                .build())\n            .topologyRequest(VolumeTopologyRequestArgs.builder()\n                .required(VolumeTopologyRequestRequiredArgs.builder()\n                    .topologies(                    \n                        VolumeTopologyRequestRequiredTopologyArgs.builder()\n                            .segments(Map.ofEntries(\n                                Map.entry(\"rack\", \"R1\"),\n                                Map.entry(\"zone\", \"us-east-1a\")\n                            ))\n                            .build(),\n                        VolumeTopologyRequestRequiredTopologyArgs.builder()\n                            .segments(Map.of(\"rack\", \"R2\"))\n                            .build())\n                    .build())\n                .build())\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(ebs)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  mysqlVolume:\n    type: nomad:Volume\n    name: mysql_volume\n    properties:\n      type: csi\n      pluginId: aws-ebs0\n      volumeId: mysql_volume\n      name: mysql_volume\n      externalId: ${hashistack.ebsTestVolumeId}\n      capabilities:\n        - accessMode: single-node-writer\n          attachmentMode: file-system\n      mountOptions:\n        fsType: ext4\n      topologyRequest:\n        required:\n          topologies:\n            - segments:\n                rack: R1\n                zone: us-east-1a\n            - segments:\n                rack: R2\n    options:\n      dependsOn:\n        - ${ebs}\nvariables:\n  # It can sometimes be helpful to wait for a particular plugin to be available\n  ebs:\n    fn::invoke:\n      function: nomad:getPlugin\n      arguments:\n        pluginId: aws-ebs0\n        waitForHealthy: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - **Deprecated**. Use `capability` block instead. Defines whether a volume should be available concurrently. Possible values are:\n- `single-node-reader-only`\n- `single-node-writer`\n- `multi-node-reader-only`\n- `multi-node-single-writer`\n- `multi-node-multi-writer`\n",
                    "deprecationMessage": "use capability instead"
                },
                "attachmentMode": {
                    "type": "string",
                    "description": "`(string: \u003cotional\u003e)` - **Deprecated**. Use `capability` block instead. The storage API that will be used by the volume.\n",
                    "deprecationMessage": "use capability instead"
                },
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/VolumeCapability:VolumeCapability"
                    },
                    "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n"
                },
                "context": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to validate the volume.\n"
                },
                "controllerRequired": {
                    "type": "boolean"
                },
                "controllersExpected": {
                    "type": "integer"
                },
                "controllersHealthy": {
                    "type": "integer"
                },
                "deregisterOnDestroy": {
                    "type": "boolean",
                    "description": "`(boolean: true)` - If true, the volume will be deregistered on destroy.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the physical volume from the storage provider.\n"
                },
                "mountOptions": {
                    "$ref": "#/types/nomad:index/VolumeMountOptions:VolumeMountOptions",
                    "description": "`(block: \u003coptional\u003e)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \"default\")` - The namespace in which to register the volume.\n"
                },
                "nodesExpected": {
                    "type": "integer"
                },
                "nodesHealthy": {
                    "type": "integer"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n"
                },
                "pluginProvider": {
                    "type": "string"
                },
                "pluginProviderVersion": {
                    "type": "string"
                },
                "schedulable": {
                    "type": "boolean"
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                    "secret": true
                },
                "topologies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/VolumeTopology:VolumeTopology"
                    }
                },
                "topologyRequest": {
                    "$ref": "#/types/nomad:index/VolumeTopologyRequest:VolumeTopologyRequest",
                    "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n"
                },
                "type": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The type of the volume. Currently, only `csi` is supported.\n"
                },
                "volumeId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n"
                }
            },
            "required": [
                "controllerRequired",
                "controllersExpected",
                "controllersHealthy",
                "externalId",
                "name",
                "nodesExpected",
                "nodesHealthy",
                "pluginId",
                "pluginProvider",
                "pluginProviderVersion",
                "schedulable",
                "topologies",
                "volumeId"
            ],
            "inputProperties": {
                "accessMode": {
                    "type": "string",
                    "description": "`(string: \u003coptional\u003e)` - **Deprecated**. Use `capability` block instead. Defines whether a volume should be available concurrently. Possible values are:\n- `single-node-reader-only`\n- `single-node-writer`\n- `multi-node-reader-only`\n- `multi-node-single-writer`\n- `multi-node-multi-writer`\n",
                    "deprecationMessage": "use capability instead"
                },
                "attachmentMode": {
                    "type": "string",
                    "description": "`(string: \u003cotional\u003e)` - **Deprecated**. Use `capability` block instead. The storage API that will be used by the volume.\n",
                    "deprecationMessage": "use capability instead"
                },
                "capabilities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/nomad:index/VolumeCapability:VolumeCapability"
                    },
                    "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n"
                },
                "context": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to validate the volume.\n"
                },
                "deregisterOnDestroy": {
                    "type": "boolean",
                    "description": "`(boolean: true)` - If true, the volume will be deregistered on destroy.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the physical volume from the storage provider.\n",
                    "willReplaceOnChanges": true
                },
                "mountOptions": {
                    "$ref": "#/types/nomad:index/VolumeMountOptions:VolumeMountOptions",
                    "description": "`(block: \u003coptional\u003e)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "`(string: \"default\")` - The namespace in which to register the volume.\n",
                    "willReplaceOnChanges": true
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                },
                "pluginId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n",
                    "willReplaceOnChanges": true
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                    "secret": true
                },
                "topologyRequest": {
                    "$ref": "#/types/nomad:index/VolumeTopologyRequest:VolumeTopologyRequest",
                    "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The type of the volume. Currently, only `csi` is supported.\n",
                    "willReplaceOnChanges": true
                },
                "volumeId": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "externalId",
                "pluginId",
                "volumeId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Volume resources.\n",
                "properties": {
                    "accessMode": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - **Deprecated**. Use `capability` block instead. Defines whether a volume should be available concurrently. Possible values are:\n- `single-node-reader-only`\n- `single-node-writer`\n- `multi-node-reader-only`\n- `multi-node-single-writer`\n- `multi-node-multi-writer`\n",
                        "deprecationMessage": "use capability instead"
                    },
                    "attachmentMode": {
                        "type": "string",
                        "description": "`(string: \u003cotional\u003e)` - **Deprecated**. Use `capability` block instead. The storage API that will be used by the volume.\n",
                        "deprecationMessage": "use capability instead"
                    },
                    "capabilities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/VolumeCapability:VolumeCapability"
                        },
                        "description": "`(``Capability``: \u003crequired\u003e)` - Options for validating the capability of a volume.\n"
                    },
                    "context": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to validate the volume.\n"
                    },
                    "controllerRequired": {
                        "type": "boolean"
                    },
                    "controllersExpected": {
                        "type": "integer"
                    },
                    "controllersHealthy": {
                        "type": "integer"
                    },
                    "deregisterOnDestroy": {
                        "type": "boolean",
                        "description": "`(boolean: true)` - If true, the volume will be deregistered on destroy.\n"
                    },
                    "externalId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The ID of the physical volume from the storage provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "mountOptions": {
                        "$ref": "#/types/nomad:index/VolumeMountOptions:VolumeMountOptions",
                        "description": "`(block: \u003coptional\u003e)` Options for mounting `block-device` volumes without a pre-formatted file system.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The display name for the volume.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "`(string: \"default\")` - The namespace in which to register the volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodesExpected": {
                        "type": "integer"
                    },
                    "nodesHealthy": {
                        "type": "integer"
                    },
                    "parameters": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings passed directly to the CSI plugin to configure the volume.\n"
                    },
                    "pluginId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The ID of the Nomad plugin for registering this volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "pluginProvider": {
                        "type": "string"
                    },
                    "pluginProviderVersion": {
                        "type": "string"
                    },
                    "schedulable": {
                        "type": "boolean"
                    },
                    "secrets": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string: \u003coptional\u003e)` - An optional key-value map of strings used as credentials for publishing and unpublishing volumes.\n",
                        "secret": true
                    },
                    "topologies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/nomad:index/VolumeTopology:VolumeTopology"
                        }
                    },
                    "topologyRequest": {
                        "$ref": "#/types/nomad:index/VolumeTopologyRequest:VolumeTopologyRequest",
                        "description": "`(``TopologyRequest``: \u003coptional\u003e)` - Specify locations (region, zone, rack, etc.) where the provisioned volume is accessible from.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The type of the volume. Currently, only `csi` is supported.\n",
                        "willReplaceOnChanges": true
                    },
                    "volumeId": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The unique ID of the volume.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "nomad:index/getAclPolicies:getAclPolicies": {
            "description": "Retrieve a list of ACL Policies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getAclPolicies({\n    prefix: \"prod\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_acl_policies(prefix=\"prod\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetAclPolicies.Invoke(new()\n    {\n        Prefix = \"prod\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetAclPolicies(ctx, \u0026nomad.GetAclPoliciesArgs{\n\t\t\tPrefix: pulumi.StringRef(\"prod\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetAclPoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getAclPolicies(GetAclPoliciesArgs.builder()\n            .prefix(\"prod\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getAclPolicies\n      arguments:\n        prefix: prod\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclPolicies.\n",
                "properties": {
                    "prefix": {
                        "type": "string",
                        "description": "`(string)` An optional string to filter ACL policies based on name prefix. If not provided, all policies are returned.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAclPolicies.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "policies": {
                        "description": "`list of maps` a list of ACL policies.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getAclPoliciesPolicy:getAclPoliciesPolicy"
                        },
                        "type": "array"
                    },
                    "prefix": {
                        "type": "string"
                    }
                },
                "required": [
                    "policies",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getAclPolicy:getAclPolicy": {
            "description": "Retrieve information on an ACL Policy.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst myPolicy = nomad.getAclPolicy({\n    name: \"my-policy\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nmy_policy = nomad.get_acl_policy(name=\"my-policy\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myPolicy = Nomad.GetAclPolicy.Invoke(new()\n    {\n        Name = \"my-policy\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.LookupAclPolicy(ctx, \u0026nomad.LookupAclPolicyArgs{\n\t\t\tName: \"my-policy\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetAclPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myPolicy = NomadFunctions.getAclPolicy(GetAclPolicyArgs.builder()\n            .name(\"my-policy\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myPolicy:\n    fn::invoke:\n      function: nomad:getAclPolicy\n      arguments:\n        name: my-policy\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "`(string)` - the name of the ACL Policy.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAclPolicy.\n",
                "properties": {
                    "description": {
                        "description": "`(string)` - the description of the ACL Policy.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "name": {
                        "description": "`(string)` - the name of the ACL Policy.\n",
                        "type": "string"
                    },
                    "rules": {
                        "description": "`(string)` - the ACL Policy rules in HCL format.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "name",
                    "rules",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getAclRole:getAclRole": {
            "description": "Get information on an ACL Role.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getAclRole({\n    id: \"aa534e09-6a07-0a45-2295-a7f77063d429\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_acl_role(id=\"aa534e09-6a07-0a45-2295-a7f77063d429\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetAclRole.Invoke(new()\n    {\n        Id = \"aa534e09-6a07-0a45-2295-a7f77063d429\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.LookupAclRole(ctx, \u0026nomad.LookupAclRoleArgs{\n\t\t\tId: \"aa534e09-6a07-0a45-2295-a7f77063d429\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetAclRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getAclRole(GetAclRoleArgs.builder()\n            .id(\"aa534e09-6a07-0a45-2295-a7f77063d429\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getAclRole\n      arguments:\n        id: aa534e09-6a07-0a45-2295-a7f77063d429\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclRole.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "`(string)` The unique identifier of the ACL Role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAclRole.\n",
                "properties": {
                    "description": {
                        "description": "`(string)` - The description of the ACL Role.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "`(string)` - The ACL Role unique identifier.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "`(string)` - Unique name of the ACL role.\n",
                        "type": "string"
                    },
                    "policies": {
                        "description": "`(set)` - The policies applied to the role.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getAclRolePolicy:getAclRolePolicy"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "description",
                    "id",
                    "name",
                    "policies"
                ],
                "type": "object"
            }
        },
        "nomad:index/getAclRoles:getAclRoles": {
            "description": "Retrieve a list of ACL Roles.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getAclRoles({\n    prefix: \"a242\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_acl_roles(prefix=\"a242\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetAclRoles.Invoke(new()\n    {\n        Prefix = \"a242\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetAclRoles(ctx, \u0026nomad.GetAclRolesArgs{\n\t\t\tPrefix: pulumi.StringRef(\"a242\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetAclRolesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getAclRoles(GetAclRolesArgs.builder()\n            .prefix(\"a242\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getAclRoles\n      arguments:\n        prefix: a242\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclRoles.\n",
                "properties": {
                    "prefix": {
                        "type": "string",
                        "description": "`(string)` An optional string to filter ACL Roles based on ID\nprefix. If not provided, all policies are returned.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAclRoles.\n",
                "properties": {
                    "aclRoles": {
                        "items": {
                            "$ref": "#/types/nomad:index/getAclRolesAclRole:getAclRolesAclRole"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "prefix": {
                        "type": "string"
                    }
                },
                "required": [
                    "aclRoles",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getAclToken:getAclToken": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst myToken = nomad.getAclToken({\n    accessorId: \"aa534e09-6a07-0a45-2295-a7f77063d429\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nmy_token = nomad.get_acl_token(accessor_id=\"aa534e09-6a07-0a45-2295-a7f77063d429\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myToken = Nomad.GetAclToken.Invoke(new()\n    {\n        AccessorId = \"aa534e09-6a07-0a45-2295-a7f77063d429\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.LookupAclToken(ctx, \u0026nomad.LookupAclTokenArgs{\n\t\t\tAccessorId: \"aa534e09-6a07-0a45-2295-a7f77063d429\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetAclTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myToken = NomadFunctions.getAclToken(GetAclTokenArgs.builder()\n            .accessorId(\"aa534e09-6a07-0a45-2295-a7f77063d429\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myToken:\n    fn::invoke:\n      function: nomad:getAclToken\n      arguments:\n        accessorId: aa534e09-6a07-0a45-2295-a7f77063d429\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclToken.\n",
                "properties": {
                    "accessorId": {
                        "type": "string",
                        "description": "`(string)` Non-sensitive identifier for this token.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accessorId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAclToken.\n",
                "properties": {
                    "accessorId": {
                        "description": "`(string)` Non-sensitive identifier for this token.\n",
                        "type": "string"
                    },
                    "createTime": {
                        "description": "`(string)` Date and time the token was created.\n",
                        "type": "string"
                    },
                    "expirationTime": {
                        "description": "`(string)` - The timestamp after which the token is\nconsidered expired and eligible for destruction.\n",
                        "type": "string"
                    },
                    "expirationTtl": {
                        "description": "`(string)` The expiration TTL for the token.\n",
                        "type": "string"
                    },
                    "global": {
                        "description": "`(bool)` Whether the token is replicated to all regions, or if it \nwill only be used in the region it was created.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "name": {
                        "description": "`(string)` Non-sensitive identifier for this token.\n",
                        "type": "string"
                    },
                    "policies": {
                        "description": "`(list of strings)` List of policy names associated with this token.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "roles": {
                        "description": "`(set: [])` - The list of roles attached to the token. Each entry has\n`name` and `id` attributes.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getAclTokenRole:getAclTokenRole"
                        },
                        "type": "array"
                    },
                    "secretId": {
                        "description": "`(string)` The token value itself.\n",
                        "secret": true,
                        "type": "string"
                    },
                    "type": {
                        "description": "`(string)` The type of the token.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accessorId",
                    "createTime",
                    "expirationTime",
                    "expirationTtl",
                    "global",
                    "name",
                    "policies",
                    "roles",
                    "secretId",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getAclTokens:getAclTokens": {
            "description": "Get a list of ACL tokens.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst tokens = nomad.getAclTokens({\n    prefix: \"a242\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\ntokens = nomad.get_acl_tokens(prefix=\"a242\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tokens = Nomad.GetAclTokens.Invoke(new()\n    {\n        Prefix = \"a242\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetAclTokens(ctx, \u0026nomad.GetAclTokensArgs{\n\t\t\tPrefix: pulumi.StringRef(\"a242\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetAclTokensArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var tokens = NomadFunctions.getAclTokens(GetAclTokensArgs.builder()\n            .prefix(\"a242\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  tokens:\n    fn::invoke:\n      function: nomad:getAclTokens\n      arguments:\n        prefix: a242\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclTokens.\n",
                "properties": {
                    "prefix": {
                        "type": "string",
                        "description": "`(string)` Optional prefix to filter the tokens.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAclTokens.\n",
                "properties": {
                    "aclTokens": {
                        "description": "`(list of objects)` The list of tokens found in the given prefix.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getAclTokensAclToken:getAclTokensAclToken"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "prefix": {
                        "type": "string"
                    }
                },
                "required": [
                    "aclTokens",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getAllocations:getAllocations": {
            "description": "Retrieve a list of allocations from Nomad.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getAllocations({\n    filter: \"JobID == \\\"example\\\"\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_allocations(filter=\"JobID == \\\"example\\\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetAllocations.Invoke(new()\n    {\n        Filter = \"JobID == \\\"example\\\"\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetAllocations(ctx, \u0026nomad.GetAllocationsArgs{\n\t\t\tFilter: pulumi.StringRef(\"JobID == \\\"example\\\"\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetAllocationsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getAllocations(GetAllocationsArgs.builder()\n            .filter(\"JobID == \\\"example\\\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getAllocations\n      arguments:\n        filter: JobID == \"example\"\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAllocations.\n",
                "properties": {
                    "filter": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Specifies the\n[expression][nomad_api_filter] used to filter the results.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Specifies the namespace to search for\nallocations in.\n"
                    },
                    "prefix": {
                        "type": "string",
                        "description": "`(string: \u003coptional\u003e)` - Specifies a string to filter allocations\nbased on an ID prefix.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAllocations.\n",
                "properties": {
                    "allocations": {
                        "description": "`(list of allocations)` - A list of allocations matching the\nsearch criteria.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getAllocationsAllocation:getAllocationsAllocation"
                        },
                        "type": "array"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "namespace": {
                        "description": "`(string)` - The namespace the allocation belongs to.\n",
                        "type": "string"
                    },
                    "prefix": {
                        "type": "string"
                    }
                },
                "required": [
                    "allocations",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getDatacenters:getDatacenters": {
            "description": "Retrieve a list of datacenters.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst datacenters = nomad.getDatacenters({\n    prefix: \"prod\",\n    ignoreDownNodes: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\ndatacenters = nomad.get_datacenters(prefix=\"prod\",\n    ignore_down_nodes=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenters = Nomad.GetDatacenters.Invoke(new()\n    {\n        Prefix = \"prod\",\n        IgnoreDownNodes = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetDatacenters(ctx, \u0026nomad.GetDatacentersArgs{\n\t\t\tPrefix:          pulumi.StringRef(\"prod\"),\n\t\t\tIgnoreDownNodes: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetDatacentersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenters = NomadFunctions.getDatacenters(GetDatacentersArgs.builder()\n            .prefix(\"prod\")\n            .ignoreDownNodes(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenters:\n    fn::invoke:\n      function: nomad:getDatacenters\n      arguments:\n        prefix: prod\n        ignoreDownNodes: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatacenters.\n",
                "properties": {
                    "ignoreDownNodes": {
                        "type": "boolean",
                        "description": "`(bool: false)`: An optional flag that, if set to `true` will ignore down nodes when compiling the list of datacenters.\n"
                    },
                    "prefix": {
                        "type": "string",
                        "description": "`(string)`: An optional string to filter datacenters based on name prefix. If not provided, all datacenters are returned.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatacenters.\n",
                "properties": {
                    "datacenters": {
                        "description": "`list(string)` a list of datacenters.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "ignoreDownNodes": {
                        "type": "boolean"
                    },
                    "prefix": {
                        "type": "string"
                    }
                },
                "required": [
                    "datacenters",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getDeployments:getDeployments": {
            "description": "Retrieve a list of deployments in Nomad.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getDeployments({});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_deployments()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetDeployments.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetDeployments(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getDeployments(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getDeployments\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getDeployments.\n",
                "properties": {
                    "deployments": {
                        "description": "`list of maps` a list of deployments in the cluster.\n* `ID`: `string` Deployment ID.\n* `JobID`: `string` Job ID associated with the deployment.\n* `JobVersion`: `string` Job version.\n* `Status`: `string` Deployment status.\n* `StatusDescription`: `string` Detailed description of the deployment's status.\n",
                        "items": {
                            "additionalProperties": {
                                "type": "string"
                            },
                            "type": "object"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    }
                },
                "required": [
                    "deployments",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getDynamicHostVolume:getDynamicHostVolume": {
            "description": "Get information on a dynamic host volume from Nomad.\n\n## Example Usage\n\nCheck for the existing of a host volume:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getDynamicHostVolume({\n    namespace: \"prod\",\n    id: \"d688ff7a-d299-11ef-ae3c-6f2400953c18\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_dynamic_host_volume(namespace=\"prod\",\n    id=\"d688ff7a-d299-11ef-ae3c-6f2400953c18\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetDynamicHostVolume.Invoke(new()\n    {\n        Namespace = \"prod\",\n        Id = \"d688ff7a-d299-11ef-ae3c-6f2400953c18\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.LookupDynamicHostVolume(ctx, \u0026nomad.LookupDynamicHostVolumeArgs{\n\t\t\tNamespace: pulumi.StringRef(\"prod\"),\n\t\t\tId:        \"d688ff7a-d299-11ef-ae3c-6f2400953c18\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetDynamicHostVolumeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getDynamicHostVolume(GetDynamicHostVolumeArgs.builder()\n            .namespace(\"prod\")\n            .id(\"d688ff7a-d299-11ef-ae3c-6f2400953c18\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getDynamicHostVolume\n      arguments:\n        namespace: prod\n        id: d688ff7a-d299-11ef-ae3c-6f2400953c18\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nThis will check for a dynamic host volume with the ID\n`d688ff7a-d299-11ef-ae3c-6f2400953c18`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDynamicHostVolume.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "`(string)` - the ID of the volume\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "`(string)` - the namespace of the volume. Defaults to `\"default\"`\n"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDynamicHostVolume.\n",
                "properties": {
                    "capabilities": {
                        "description": "`(block)` - Option for validating the capability of a\nvolume. Each capability block has the following attributes:\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getDynamicHostVolumeCapability:getDynamicHostVolumeCapability"
                        },
                        "type": "array"
                    },
                    "capacity": {
                        "description": "`(string)` - The size of the volume, in human-friendly format\n(ex. 10 GiB)\n",
                        "type": "string"
                    },
                    "capacityBytes": {
                        "description": "`(int)` - The size of the volume, in bytes.\n",
                        "type": "integer"
                    },
                    "capacityMax": {
                        "description": "`(string)` - The requested maximum capacity of the volume, in\nhuman-friendly format (ex. 10 GiB).\n",
                        "type": "string"
                    },
                    "capacityMaxBytes": {
                        "description": "`(string)` - The requested maximum capacity of the\nvolume, in bytes.\n",
                        "type": "integer"
                    },
                    "capacityMin": {
                        "description": "`(string)` - The requested minimum capacity of the volume, in\nhuman-friendly format (ex. 10 GiB).\n",
                        "type": "string"
                    },
                    "capacityMinBytes": {
                        "description": "`(string)` - The requested minimum capacity of the\nvolume, in bytes.\n",
                        "type": "integer"
                    },
                    "constraints": {
                        "description": "`(block)` - The restrictions used to place the volume on a node,\nsimilar to the [`constraint`][] block on a Nomad job specification. A volume\nmay have multiple `constraint` blocks. Each constraint block has the following\nattributes.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getDynamicHostVolumeConstraint:getDynamicHostVolumeConstraint"
                        },
                        "type": "array"
                    },
                    "hostPath": {
                        "description": "`(string)` - The path on disk where the volume exists.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "name": {
                        "description": "`(string)` - The name of the volume, which is used as the\n[`volume.source`][volume_source] field in job specifications that claim this\nvolume. Host volume names are be unique per node. Names are visible to any\nuser with `node:read` ACL, even across namespaces, so they should not be\ntreated as sensitive values.\n",
                        "type": "string"
                    },
                    "namespace": {
                        "description": "`(string)` - The namespace of the volume.\n",
                        "type": "string"
                    },
                    "nodeId": {
                        "description": "`(string)` - A specific node where the volume is mounted.\n",
                        "type": "string"
                    },
                    "nodePool": {
                        "description": "`(string: \u003coptional\u003e)` - The node pool of the node where the\nvolume is mounted.\n",
                        "type": "string"
                    },
                    "parameters": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map\u003cstring|string\u003e)` - A key-value map of strings\npassed directly to the plugin to configure the volume. The details of these\nparameters are specific to the plugin.\n",
                        "type": "object"
                    },
                    "pluginId": {
                        "description": "`(string: \u003crequired\u003e)` - The ID of the [dynamic host volume\nplugin][dhv_plugin] that manages this volume.\n",
                        "type": "string"
                    },
                    "state": {
                        "type": "string"
                    }
                },
                "required": [
                    "capabilities",
                    "capacity",
                    "capacityBytes",
                    "capacityMax",
                    "capacityMaxBytes",
                    "capacityMin",
                    "capacityMinBytes",
                    "constraints",
                    "hostPath",
                    "id",
                    "name",
                    "nodeId",
                    "nodePool",
                    "parameters",
                    "pluginId",
                    "state"
                ],
                "type": "object"
            }
        },
        "nomad:index/getJob:getJob": {
            "description": "Get information on a job ID. The aim of this datasource is to enable\nyou to act on various settings and states of a particular job.\n\nAn error is triggered if zero or more than one result is returned by the query.\n\n## Example Usage\n\nGet the data about a snapshot:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getJob({\n    jobId: \"example\",\n    namespace: \"dev\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_job(job_id=\"example\",\n    namespace=\"dev\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetJob.Invoke(new()\n    {\n        JobId = \"example\",\n        Namespace = \"dev\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.LookupJob(ctx, \u0026nomad.LookupJobArgs{\n\t\t\tJobId:     \"example\",\n\t\t\tNamespace: pulumi.StringRef(\"dev\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetJobArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getJob(GetJobArgs.builder()\n            .jobId(\"example\")\n            .namespace(\"dev\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getJob\n      arguments:\n        jobId: example\n        namespace: dev\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getJob.\n",
                "properties": {
                    "jobId": {
                        "type": "string",
                        "description": "`(string)` ID of the job.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "`(string)` Namespace of the specified job.\n"
                    }
                },
                "type": "object",
                "required": [
                    "jobId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getJob.\n",
                "properties": {
                    "allAtOnce": {
                        "description": "`(boolean)`  If the scheduler can make partial placements on oversubscribed nodes.\n",
                        "type": "boolean"
                    },
                    "constraints": {
                        "items": {
                            "$ref": "#/types/nomad:index/getJobConstraint:getJobConstraint"
                        },
                        "type": "array"
                    },
                    "createIndex": {
                        "description": "`(integer)` Creation Index.\n",
                        "type": "integer"
                    },
                    "datacenters": {
                        "description": "`(list of strings)` Datacenters allowed to run the specified job.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "jobId": {
                        "type": "string"
                    },
                    "jobModifyIndex": {
                        "description": "`(integer)` Job modify index (used for version verification).\n",
                        "type": "integer"
                    },
                    "modifyIndex": {
                        "description": "`(integer)` Modification Index.\n",
                        "type": "integer"
                    },
                    "name": {
                        "description": "`(string)` Name of the job.\n",
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "parentId": {
                        "description": "`(string)` Job's parent ID.\n",
                        "type": "string"
                    },
                    "periodicConfigs": {
                        "description": "`(list of maps)` Job's periodic configuration (time based scheduling).\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getJobPeriodicConfig:getJobPeriodicConfig"
                        },
                        "type": "array"
                    },
                    "priority": {
                        "description": "`(integer)` Used for the prioritization of scheduling and resource access.\n",
                        "type": "integer"
                    },
                    "region": {
                        "description": "`(string)` Region where the Nomad cluster resides.\n",
                        "type": "string"
                    },
                    "stable": {
                        "description": "`(boolean)` Job stability status.\n",
                        "type": "boolean"
                    },
                    "status": {
                        "description": "`(string)` Execution status of the specified job.\n",
                        "type": "string"
                    },
                    "statusDescription": {
                        "description": "`(string)` Status description of the specified job.\n",
                        "type": "string"
                    },
                    "stop": {
                        "description": "`(boolean)` Job enabled status.\n",
                        "type": "boolean"
                    },
                    "submitTime": {
                        "description": "`(integer)` Job submission date.\n",
                        "type": "integer"
                    },
                    "taskGroups": {
                        "description": "`(list of maps)` A list of of the job's task groups.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getJobTaskGroup:getJobTaskGroup"
                        },
                        "type": "array"
                    },
                    "type": {
                        "description": "`(string)` Scheduler type used during job creation.\n",
                        "type": "string"
                    },
                    "version": {
                        "description": "`(integer)` Version of the specified job.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "allAtOnce",
                    "constraints",
                    "createIndex",
                    "datacenters",
                    "jobId",
                    "jobModifyIndex",
                    "modifyIndex",
                    "name",
                    "parentId",
                    "periodicConfigs",
                    "priority",
                    "region",
                    "stable",
                    "status",
                    "statusDescription",
                    "stop",
                    "submitTime",
                    "taskGroups",
                    "type",
                    "version",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getJobParser:getJobParser": {
            "description": "Parse a HCL jobspec and produce the equivalent JSON encoded job.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getJobParser.\n",
                "properties": {
                    "canonicalize": {
                        "type": "boolean",
                        "description": "`(boolean: true)` - flag to enable setting any unset fields to their default values.\n"
                    },
                    "hcl": {
                        "type": "string",
                        "description": "`(string)` - the HCL definition of the job.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hcl"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getJobParser.\n",
                "properties": {
                    "canonicalize": {
                        "description": "`(boolean: true)` - flag to enable setting any unset fields to their default values.\n",
                        "type": "boolean"
                    },
                    "hcl": {
                        "description": "`(string)` - the HCL definition of the job.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "json": {
                        "description": "`(string)` - the parsed job as JSON string.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "hcl",
                    "json",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getJwks:getJwks": {
            "description": "Retrieve the cluster JWKS public keys.\n\nThe keys are returned both as a list of maps (`keys`), and as a list of PEM-encoded strings\n(`pem_keys`), which may be more convenient for use.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getJwks({});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_jwks()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetJwks.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetJwks(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getJwks(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getJwks\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getJwks.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "keys": {
                        "description": "`list of maps` a list of JWK keys in structured format: see [RFC7517](https://datatracker.ietf.org/doc/html/rfc7517) for the\nJWK field meanings.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getJwksKey:getJwksKey"
                        },
                        "type": "array"
                    },
                    "pemKeys": {
                        "description": "`list of strings` a list JWK keys rendered as PEM-encoded X.509 keys\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "keys",
                    "pemKeys",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getNamespace:getNamespace": {
            "description": "Get information about a namespace in Nomad.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst namespaces = nomad.getNamespace({\n    name: \"default\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nnamespaces = nomad.get_namespace(name=\"default\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var namespaces = Nomad.GetNamespace.Invoke(new()\n    {\n        Name = \"default\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.LookupNamespace(ctx, \u0026nomad.LookupNamespaceArgs{\n\t\t\tName: \"default\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetNamespaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var namespaces = NomadFunctions.getNamespace(GetNamespaceArgs.builder()\n            .name(\"default\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  namespaces:\n    fn::invoke:\n      function: nomad:getNamespace\n      arguments:\n        name: default\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNamespace.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "`(string)` - The name of the namespace.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNamespace.\n",
                "properties": {
                    "capabilities": {
                        "description": "`(block)` - Capabilities of the namespace\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getNamespaceCapability:getNamespaceCapability"
                        },
                        "type": "array"
                    },
                    "description": {
                        "description": "`(string)` - The description of the namespace.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "meta": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string)` -  Arbitrary KV metadata associated with the namespace.\n",
                        "type": "object"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nodePoolConfigs": {
                        "items": {
                            "$ref": "#/types/nomad:index/getNamespaceNodePoolConfig:getNamespaceNodePoolConfig"
                        },
                        "type": "array"
                    },
                    "quota": {
                        "description": "`(string)` - The quota associated with the namespace.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "capabilities",
                    "description",
                    "meta",
                    "name",
                    "nodePoolConfigs",
                    "quota",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getNamespaces:getNamespaces": {
            "description": "Retrieve a list of namespaces available in Nomad.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst namespaces = nomad.getNamespaces({});\nconst namespace: nomad.AclPolicy[] = [];\nnamespaces.then(namespaces =\u003e namespaces.namespaces).length.apply(rangeBody =\u003e {\n    for (const range = {value: 0}; range.value \u003c rangeBody; range.value++) {\n        namespace.push(new nomad.AclPolicy(`namespace-${range.value}`, {\n            name: namespaces.then(namespaces =\u003e `namespace-${namespaces[range.value]}`),\n            description: namespaces.then(namespaces =\u003e `Write to the namespace ${namespaces[range.value]}`),\n            rulesHcl: namespaces.then(namespaces =\u003e `namespace \"${namespaces[range.value]}\" {\n  policy = \"write\"\n}\n`),\n        }));\n    }\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nnamespaces = nomad.get_namespaces()\nnamespace = []\ndef create_namespace(range_body):\n    for range in [{\"value\": i} for i in range(0, range_body)]:\n        namespace.append(nomad.AclPolicy(f\"namespace-{range['value']}\",\n            name=f\"namespace-{namespaces[range['value']]}\",\n            description=f\"Write to the namespace {namespaces[range['value']]}\",\n            rules_hcl=f\"\"\"namespace \"{namespaces[range[\"value\"]]}\" {{\n  policy = \"write\"\n}}\n\"\"\"))\n\n(len(namespaces.namespaces)).apply(create_namespace)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var namespaces = Nomad.GetNamespaces.Invoke();\n\n    var @namespace = new List\u003cNomad.AclPolicy\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c namespaces.Apply(getNamespacesResult =\u003e getNamespacesResult.Namespaces).Length; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        @namespace.Add(new Nomad.AclPolicy($\"namespace-{range.Value}\", new()\n        {\n            Name = $\"namespace-{namespaces[range.Value]}\",\n            Description = $\"Write to the namespace {namespaces[range.Value]}\",\n            RulesHcl = @$\"namespace \"\"{namespaces[range.Value]}\"\" {{\n  policy = \"\"write\"\"\n}}\n\",\n        }));\n    }\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnamespaces, err := nomad.GetNamespaces(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar namespace []*nomad.AclPolicy\n\t\tfor index := 0; index \u003c int(len(namespaces.Namespaces)); index++ {\n\t\t\tkey0 := index\n\t\t\tval0 := index\n\t\t\t__res, err := nomad.NewAclPolicy(ctx, fmt.Sprintf(\"namespace-%v\", key0), \u0026nomad.AclPolicyArgs{\n\t\t\t\tName:        pulumi.Sprintf(\"namespace-%v\", namespaces[val0]),\n\t\t\t\tDescription: pulumi.Sprintf(\"Write to the namespace %v\", namespaces[val0]),\n\t\t\t\tRulesHcl:    pulumi.Sprintf(\"namespace \\\"%v\\\" {\\n  policy = \\\"write\\\"\\n}\\n\", namespaces[val0]),\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tnamespace = append(namespace, __res)\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.AclPolicy;\nimport com.pulumi.nomad.AclPolicyArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var namespaces = NomadFunctions.getNamespaces(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n        for (var i = 0; i \u003c namespaces.namespaces().length(); i++) {\n            new AclPolicy(\"namespace-\" + i, AclPolicyArgs.builder()\n                .name(String.format(\"namespace-%s\", namespaces[range.value()]))\n                .description(String.format(\"Write to the namespace %s\", namespaces[range.value()]))\n                .rulesHcl(\"\"\"\nnamespace \"%s\" {\n  policy = \"write\"\n}\n\", namespaces[range.value()]))\n                .build());\n\n        \n}\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getNamespaces.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "namespaces": {
                        "description": "`(list of strings)` - a list of namespaces available in the cluster.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "namespaces",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getNodePool:getNodePool": {
            "description": "Get information about a node pool in Nomad.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst dev = nomad.getNodePool({\n    name: \"dev\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\ndev = nomad.get_node_pool(name=\"dev\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dev = Nomad.GetNodePool.Invoke(new()\n    {\n        Name = \"dev\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.LookupNodePool(ctx, \u0026nomad.LookupNodePoolArgs{\n\t\t\tName: \"dev\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetNodePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dev = NomadFunctions.getNodePool(GetNodePoolArgs.builder()\n            .name(\"dev\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  dev:\n    fn::invoke:\n      function: nomad:getNodePool\n      arguments:\n        name: dev\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNodePool.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "`(string)` - The name of the node pool to fetch.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNodePool.\n",
                "properties": {
                    "description": {
                        "description": "`(string)` - The description of the node pool.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "meta": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string)` - Arbitrary KV metadata associated with the\nnode pool.\n",
                        "type": "object"
                    },
                    "name": {
                        "type": "string"
                    },
                    "schedulerConfigs": {
                        "description": "`(block)` - Scheduler configuration for the node pool.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getNodePoolSchedulerConfig:getNodePoolSchedulerConfig"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "description",
                    "meta",
                    "name",
                    "schedulerConfigs",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getNodePools:getNodePools": {
            "description": "Retrieve a list of node pools available in Nomad.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst prod = nomad.getNodePools({\n    filter: \"Meta.env == \\\"prod\\\"\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nprod = nomad.get_node_pools(filter=\"Meta.env == \\\"prod\\\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prod = Nomad.GetNodePools.Invoke(new()\n    {\n        Filter = \"Meta.env == \\\"prod\\\"\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetNodePools(ctx, \u0026nomad.GetNodePoolsArgs{\n\t\t\tFilter: pulumi.StringRef(\"Meta.env == \\\"prod\\\"\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetNodePoolsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var prod = NomadFunctions.getNodePools(GetNodePoolsArgs.builder()\n            .filter(\"Meta.env == \\\"prod\\\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  prod:\n    fn::invoke:\n      function: nomad:getNodePools\n      arguments:\n        filter: Meta.env == \"prod\"\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNodePools.\n",
                "properties": {
                    "filter": {
                        "type": "string",
                        "description": "`(string)` - Specifies the [expression][nomad_api_filter] used to\nfilter the results.\n"
                    },
                    "prefix": {
                        "type": "string",
                        "description": "`(string)` - Specifies a string to filter node pools based on a name\nprefix.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNodePools.\n",
                "properties": {
                    "filter": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "nodePools": {
                        "description": "`(list of node pools)` - A list of node pools matching the\nsearch criteria.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getNodePoolsNodePool:getNodePoolsNodePool"
                        },
                        "type": "array"
                    },
                    "prefix": {
                        "type": "string"
                    }
                },
                "required": [
                    "nodePools",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getPlugin:getPlugin": {
            "description": "Lookup a plugin by ID. The aim of this datasource is to determine whether\na particular plugin exists on the cluster, to find information on the health\nand availability of the plugin, and to optionally wait for the plugin\nbefore performing actions the require an available plugin controller.\n\nIf a plugin with the specified ID does not exist and the datasource is not\nconfigured to wait, it will result in an error. For simple existence checks,\nuse the `nomad.getPlugins` listing datasource.\n\n## Example Usage\n\nCheck for the existence of a plugin:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst ebs = nomad.getPlugin({\n    pluginId: \"aws-ebs0\",\n    waitForHealthy: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nebs = nomad.get_plugin(plugin_id=\"aws-ebs0\",\n    wait_for_healthy=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ebs = Nomad.GetPlugin.Invoke(new()\n    {\n        PluginId = \"aws-ebs0\",\n        WaitForHealthy = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetPlugin(ctx, \u0026nomad.GetPluginArgs{\n\t\t\tPluginId:       \"aws-ebs0\",\n\t\t\tWaitForHealthy: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetPluginArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var ebs = NomadFunctions.getPlugin(GetPluginArgs.builder()\n            .pluginId(\"aws-ebs0\")\n            .waitForHealthy(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  ebs:\n    fn::invoke:\n      function: nomad:getPlugin\n      arguments:\n        pluginId: aws-ebs0\n        waitForHealthy: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nThis will check for a plugin with the ID `aws-ebs0`, waiting until the plugin\nis healthy before returning.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPlugin.\n",
                "properties": {
                    "pluginId": {
                        "type": "string",
                        "description": "`(string)` ID of the plugin.\n"
                    },
                    "waitForHealthy": {
                        "type": "boolean",
                        "description": "`(boolean)` retry until the plugin exists and all controllers are healthy\n"
                    },
                    "waitForRegistration": {
                        "type": "boolean",
                        "description": "`(boolean)` if the plugin doesn't exist, retry until it does\n"
                    }
                },
                "type": "object",
                "required": [
                    "pluginId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPlugin.\n",
                "properties": {
                    "controllerRequired": {
                        "description": "`(boolean)` Whether a controller is required.\n",
                        "type": "boolean"
                    },
                    "controllersExpected": {
                        "description": "`(integer)` The number of registered controllers.\n",
                        "type": "integer"
                    },
                    "controllersHealthy": {
                        "description": "`(integer)` The number of healthy controllers.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "nodes": {
                        "items": {
                            "$ref": "#/types/nomad:index/getPluginNode:getPluginNode"
                        },
                        "type": "array"
                    },
                    "nodesExpected": {
                        "description": "`(integer)` The number of registered nodes.\n",
                        "type": "integer"
                    },
                    "nodesHealthy": {
                        "description": "`(integer)` The number of healthy nodes.\n",
                        "type": "integer"
                    },
                    "pluginId": {
                        "description": "`(string)` ID of the plugin\n",
                        "type": "string"
                    },
                    "pluginProvider": {
                        "description": "`(string)` Plugin provider name\n",
                        "type": "string"
                    },
                    "pluginProviderVersion": {
                        "description": "`(string)` Plugin provider version\n",
                        "type": "string"
                    },
                    "waitForHealthy": {
                        "type": "boolean"
                    },
                    "waitForRegistration": {
                        "type": "boolean"
                    }
                },
                "required": [
                    "controllerRequired",
                    "controllersExpected",
                    "controllersHealthy",
                    "nodes",
                    "nodesExpected",
                    "nodesHealthy",
                    "pluginId",
                    "pluginProvider",
                    "pluginProviderVersion",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getPlugins:getPlugins": {
            "description": "Retrieve a list of dynamic plugins in Nomad.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getPlugins({});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_plugins()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetPlugins.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetPlugins(ctx, \u0026nomad.GetPluginsArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetPluginsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getPlugins(GetPluginsArgs.builder()\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getPlugins\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPlugins.\n",
                "properties": {
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPlugins.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "plugins": {
                        "description": "`(list of maps)` a list of dynamic plugins registered in the cluster.\n",
                        "items": {
                            "additionalProperties": {
                                "type": "string"
                            },
                            "type": "object"
                        },
                        "type": "array"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "required": [
                    "plugins",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getRegions:getRegions": {
            "description": "Retrieve a list of regions available in Nomad.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nfunction notImplemented(message: string) {\n    throw new Error(message);\n}\n\nconst myRegions = nomad.getRegions({});\nconst jobs = notImplemented(\"The template_file data resource is not yet supported.\");\nconst app: nomad.Job[] = [];\nmyRegions.then(myRegions =\u003e myRegions.regions).length.apply(rangeBody =\u003e {\n    for (const range = {value: 0}; range.value \u003c rangeBody; range.value++) {\n        app.push(new nomad.Job(`app-${range.value}`, {jobspec: jobs[range.value].rendered}));\n    }\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\n\ndef not_implemented(msg):\n    raise NotImplementedError(msg)\n\nmy_regions = nomad.get_regions()\njobs = not_implemented(\"The template_file data resource is not yet supported.\")\napp = []\ndef create_app(range_body):\n    for range in [{\"value\": i} for i in range(0, range_body)]:\n        app.append(nomad.Job(f\"app-{range['value']}\", jobspec=jobs[range[\"value\"]][\"rendered\"]))\n\n(len(my_regions.regions)).apply(create_app)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\n\t\nobject NotImplemented(string errorMessage) \n{\n    throw new System.NotImplementedException(errorMessage);\n}\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myRegions = Nomad.GetRegions.Invoke();\n\n    var jobs = NotImplemented(\"The template_file data resource is not yet supported.\");\n\n    var app = new List\u003cNomad.Job\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c myRegions.Apply(getRegionsResult =\u003e getRegionsResult.Regions).Length; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        app.Add(new Nomad.Job($\"app-{range.Value}\", new()\n        {\n            Jobspec = jobs[range.Value].Rendered,\n        }));\n    }\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc notImplemented(message string) pulumi.AnyOutput {\n\tpanic(message)\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyRegions, err := nomad.GetRegions(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjobs := notImplemented(\"The template_file data resource is not yet supported.\")\n\t\tvar app []*nomad.Job\n\t\tfor index := 0; index \u003c int(len(myRegions.Regions)); index++ {\n\t\t\tkey0 := index\n\t\t\tval0 := index\n\t\t\t__res, err := nomad.NewJob(ctx, fmt.Sprintf(\"app-%v\", key0), \u0026nomad.JobArgs{\n\t\t\t\tJobspec: jobs[val0].Rendered,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tapp = append(app, __res)\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getRegions.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "regions": {
                        "description": "`(list of strings)` - a list of regions available in the cluster.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "regions",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getScalingPolicies:getScalingPolicies": {
            "description": "Retrieve a list of Scaling Policies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getScalingPolicies({\n    jobId: \"webapp\",\n    type: \"horizontal\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_scaling_policies(job_id=\"webapp\",\n    type=\"horizontal\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetScalingPolicies.Invoke(new()\n    {\n        JobId = \"webapp\",\n        Type = \"horizontal\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetScalingPolicies(ctx, \u0026nomad.GetScalingPoliciesArgs{\n\t\t\tJobId: pulumi.StringRef(\"webapp\"),\n\t\t\tType:  pulumi.StringRef(\"horizontal\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetScalingPoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getScalingPolicies(GetScalingPoliciesArgs.builder()\n            .jobId(\"webapp\")\n            .type(\"horizontal\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getScalingPolicies\n      arguments:\n        jobId: webapp\n        type: horizontal\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getScalingPolicies.\n",
                "properties": {
                    "jobId": {
                        "type": "string",
                        "description": "`(string)` - An optional string to filter scaling policies based on the target job. If not provided, policies for all jobs are returned.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "`(string)` - An optional string to filter scaling policies based on policy type. If not provided, policies of all types are returned.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getScalingPolicies.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "jobId": {
                        "type": "string"
                    },
                    "policies": {
                        "description": "`list of maps` - A list of scaling policies.\n",
                        "items": {
                            "$ref": "#/types/nomad:index/getScalingPoliciesPolicy:getScalingPoliciesPolicy"
                        },
                        "type": "array"
                    },
                    "type": {
                        "description": "`(string)` - The scaling policy type.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "policies",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getScalingPolicy:getScalingPolicy": {
            "description": "Retrieve a Scaling Policy.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getScalingPolicy({\n    id: \"ad19848d-1921-179c-affa-244a3543be88\",\n});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_scaling_policy(id=\"ad19848d-1921-179c-affa-244a3543be88\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetScalingPolicy.Invoke(new()\n    {\n        Id = \"ad19848d-1921-179c-affa-244a3543be88\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetScalingPolicy(ctx, \u0026nomad.GetScalingPolicyArgs{\n\t\t\tId: \"ad19848d-1921-179c-affa-244a3543be88\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetScalingPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getScalingPolicy(GetScalingPolicyArgs.builder()\n            .id(\"ad19848d-1921-179c-affa-244a3543be88\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getScalingPolicy\n      arguments:\n        id: ad19848d-1921-179c-affa-244a3543be88\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getScalingPolicy.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The  ID of the scaling policy.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getScalingPolicy.\n",
                "properties": {
                    "enabled": {
                        "description": "`(boolean)` - Whether or not the scaling policy is enabled.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string"
                    },
                    "max": {
                        "description": "`(integer)` - The maximum value set in the scaling policy.\n",
                        "type": "integer"
                    },
                    "min": {
                        "description": "`(integer)` - The minimum value set in the scaling policy.\n",
                        "type": "integer"
                    },
                    "policy": {
                        "description": "`(string)` - The policy inside the scaling policy.\n",
                        "type": "string"
                    },
                    "target": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string)` - The scaling policy target.\n",
                        "type": "object"
                    },
                    "type": {
                        "description": "`(string)` - The scaling policy type.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "enabled",
                    "id",
                    "max",
                    "min",
                    "policy",
                    "target",
                    "type"
                ],
                "type": "object"
            }
        },
        "nomad:index/getSchedulerPolicy:getSchedulerPolicy": {
            "description": "Retrieve the cluster's [scheduler configuration](https://www.nomadproject.io/api-docs/operator#sample-response-3).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst global = nomad.getSchedulerPolicy({});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nglobal_ = nomad.get_scheduler_policy()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @global = Nomad.GetSchedulerPolicy.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetSchedulerPolicy(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var global = NomadFunctions.getSchedulerPolicy(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n    }\n}\n```\n```yaml\nvariables:\n  global:\n    fn::invoke:\n      function: nomad:getSchedulerPolicy\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getSchedulerPolicy.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "memoryOversubscriptionEnabled": {
                        "description": "`(bool: false)` - When `true`, tasks may exceed their reserved memory limit.\n",
                        "type": "boolean"
                    },
                    "preemptionConfig": {
                        "additionalProperties": {
                            "type": "boolean"
                        },
                        "description": "`(map[string]bool)` - Options to enable preemption for various schedulers.\n",
                        "type": "object"
                    },
                    "schedulerAlgorithm": {
                        "description": "`(string)` - Specifies whether scheduler binpacks or spreads allocations on available nodes.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "memoryOversubscriptionEnabled",
                    "preemptionConfig",
                    "schedulerAlgorithm",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getVariable:getVariable": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = new nomad.Variable(\"example\", {path: \"path/of/existing/variable\"});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.Variable(\"example\", path=\"path/of/existing/variable\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Nomad.Variable(\"example\", new()\n    {\n        Path = \"path/of/existing/variable\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.NewVariable(ctx, \"example\", \u0026nomad.VariableArgs{\n\t\t\tPath: pulumi.String(\"path/of/existing/variable\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.Variable;\nimport com.pulumi.nomad.VariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Variable(\"example\", VariableArgs.builder()\n            .path(\"path/of/existing/variable\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: nomad:Variable\n    properties:\n      path: path/of/existing/variable\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVariable.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "`(string: \"default\")` - The namepsace in which the variable exists.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "`(string)` - Path to the existing variable.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVariable.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "items": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "`(map[string]string)` - Map of items in the variable.\n",
                        "secret": true,
                        "type": "object"
                    },
                    "namespace": {
                        "description": "`(string)` - The namespace in which the variable exists.\n",
                        "type": "string"
                    },
                    "path": {
                        "description": "`(string)` - The path at which the variable exists.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "items",
                    "path",
                    "id"
                ],
                "type": "object"
            }
        },
        "nomad:index/getVolumes:getVolumes": {
            "description": "Retrieve a list of volumes in Nomad.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as nomad from \"@pulumi/nomad\";\n\nconst example = nomad.getVolumes({});\n```\n```python\nimport pulumi\nimport pulumi_nomad as nomad\n\nexample = nomad.get_volumes()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Nomad = Pulumi.Nomad;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Nomad.GetVolumes.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-nomad/sdk/v2/go/nomad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nomad.GetVolumes(ctx, \u0026nomad.GetVolumesArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.nomad.NomadFunctions;\nimport com.pulumi.nomad.inputs.GetVolumesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NomadFunctions.getVolumes(GetVolumesArgs.builder()\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: nomad:getVolumes\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVolumes.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "`(string: \"default\")` Nomad namespace.\n"
                    },
                    "nodeId": {
                        "type": "string",
                        "description": "`(string: optional)` Volume node filter.\n"
                    },
                    "pluginId": {
                        "type": "string",
                        "description": "`(string: optional)` Plugin ID filter.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "`(string: \"csi\")` Volume type (one of `csi` or `host`)\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getVolumes.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "namespace": {
                        "description": "`string` Volume namespace.\n",
                        "type": "string"
                    },
                    "nodeId": {
                        "type": "string"
                    },
                    "pluginId": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "volumes": {
                        "description": "`list of maps` a list of volumes in the cluster.\n",
                        "items": {
                            "additionalProperties": {
                                "type": "string"
                            },
                            "type": "object"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "volumes",
                    "id"
                ],
                "type": "object"
            }
        },
        "pulumi:providers:nomad/terraformConfig": {
            "description": "This function returns a Terraform config object with terraform-namecased keys,to be used with the Terraform Module Provider.",
            "inputs": {
                "properties": {
                    "__self__": {
                        "type": "ref",
                        "$ref": "#/provider"
                    }
                },
                "type": "pulumi:providers:nomad/terraformConfig",
                "required": [
                    "__self__"
                ]
            },
            "outputs": {
                "properties": {
                    "result": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    }
                },
                "required": [
                    "result"
                ],
                "type": "object"
            }
        }
    }
}