// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package nomad

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// Registering a volume:
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-nomad/sdk/go/nomad"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		ebs, err := nomad.GetPlugin(ctx, &GetPluginArgs{
// 			PluginId:       "aws-ebs0",
// 			WaitForHealthy: pulumi.BoolRef(true),
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		_, err = nomad.NewVolume(ctx, "mysqlVolume", &nomad.VolumeArgs{
// 			Type:       pulumi.String("csi"),
// 			PluginId:   pulumi.String("aws-ebs0"),
// 			VolumeId:   pulumi.String("mysql_volume"),
// 			ExternalId: pulumi.Any(module.Hashistack.Ebs_test_volume_id),
// 			Capabilities: VolumeCapabilityArray{
// 				&VolumeCapabilityArgs{
// 					AccessMode:     pulumi.String("single-node-writer"),
// 					AttachmentMode: pulumi.String("file-system"),
// 				},
// 			},
// 			MountOptions: &VolumeMountOptionsArgs{
// 				FsType: pulumi.String("ext4"),
// 			},
// 		}, pulumi.DependsOn([]pulumi.Resource{
// 			ebs,
// 		}))
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
type Volume struct {
	pulumi.CustomResourceState

	// Defines whether a volume should be available concurrently.
	//
	// Deprecated: use capability instead
	AccessMode pulumi.StringPtrOutput `pulumi:"accessMode"`
	// The storage API that will be used by the volume.
	//
	// Deprecated: use capability instead
	AttachmentMode pulumi.StringPtrOutput `pulumi:"attachmentMode"`
	// Capabilities intended to be used in a job. At least one capability must be provided.
	Capabilities VolumeCapabilityArrayOutput `pulumi:"capabilities"`
	// An optional key-value map of strings passed directly to the CSI plugin to validate the volume.
	Context             pulumi.StringMapOutput `pulumi:"context"`
	ControllerRequired  pulumi.BoolOutput      `pulumi:"controllerRequired"`
	ControllersExpected pulumi.IntOutput       `pulumi:"controllersExpected"`
	ControllersHealthy  pulumi.IntOutput       `pulumi:"controllersHealthy"`
	// If true, the volume will be deregistered on destroy.
	DeregisterOnDestroy pulumi.BoolPtrOutput `pulumi:"deregisterOnDestroy"`
	// The ID of the physical volume from the storage provider.
	ExternalId pulumi.StringOutput `pulumi:"externalId"`
	// Options for mounting 'block-device' volumes without a pre-formatted file system.
	MountOptions VolumeMountOptionsPtrOutput `pulumi:"mountOptions"`
	// The display name of the volume.
	Name pulumi.StringOutput `pulumi:"name"`
	// The namespace in which to create the volume.
	Namespace     pulumi.StringPtrOutput `pulumi:"namespace"`
	NodesExpected pulumi.IntOutput       `pulumi:"nodesExpected"`
	NodesHealthy  pulumi.IntOutput       `pulumi:"nodesHealthy"`
	// An optional key-value map of strings passed directly to the CSI plugin to configure the volume.
	Parameters pulumi.StringMapOutput `pulumi:"parameters"`
	// The ID of the CSI plugin that manages this volume.
	PluginId              pulumi.StringOutput `pulumi:"pluginId"`
	PluginProvider        pulumi.StringOutput `pulumi:"pluginProvider"`
	PluginProviderVersion pulumi.StringOutput `pulumi:"pluginProviderVersion"`
	Schedulable           pulumi.BoolOutput   `pulumi:"schedulable"`
	// An optional key-value map of strings used as credentials for publishing and unpublishing volumes.
	Secrets pulumi.StringMapOutput `pulumi:"secrets"`
	// The type of the volume. Currently, only 'csi' is supported.
	Type pulumi.StringPtrOutput `pulumi:"type"`
	// The unique ID of the volume, how jobs will refer to the volume.
	VolumeId pulumi.StringOutput `pulumi:"volumeId"`
}

// NewVolume registers a new resource with the given unique name, arguments, and options.
func NewVolume(ctx *pulumi.Context,
	name string, args *VolumeArgs, opts ...pulumi.ResourceOption) (*Volume, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ExternalId == nil {
		return nil, errors.New("invalid value for required argument 'ExternalId'")
	}
	if args.PluginId == nil {
		return nil, errors.New("invalid value for required argument 'PluginId'")
	}
	if args.VolumeId == nil {
		return nil, errors.New("invalid value for required argument 'VolumeId'")
	}
	var resource Volume
	err := ctx.RegisterResource("nomad:index/volume:Volume", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVolume gets an existing Volume resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVolume(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VolumeState, opts ...pulumi.ResourceOption) (*Volume, error) {
	var resource Volume
	err := ctx.ReadResource("nomad:index/volume:Volume", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Volume resources.
type volumeState struct {
	// Defines whether a volume should be available concurrently.
	//
	// Deprecated: use capability instead
	AccessMode *string `pulumi:"accessMode"`
	// The storage API that will be used by the volume.
	//
	// Deprecated: use capability instead
	AttachmentMode *string `pulumi:"attachmentMode"`
	// Capabilities intended to be used in a job. At least one capability must be provided.
	Capabilities []VolumeCapability `pulumi:"capabilities"`
	// An optional key-value map of strings passed directly to the CSI plugin to validate the volume.
	Context             map[string]string `pulumi:"context"`
	ControllerRequired  *bool             `pulumi:"controllerRequired"`
	ControllersExpected *int              `pulumi:"controllersExpected"`
	ControllersHealthy  *int              `pulumi:"controllersHealthy"`
	// If true, the volume will be deregistered on destroy.
	DeregisterOnDestroy *bool `pulumi:"deregisterOnDestroy"`
	// The ID of the physical volume from the storage provider.
	ExternalId *string `pulumi:"externalId"`
	// Options for mounting 'block-device' volumes without a pre-formatted file system.
	MountOptions *VolumeMountOptions `pulumi:"mountOptions"`
	// The display name of the volume.
	Name *string `pulumi:"name"`
	// The namespace in which to create the volume.
	Namespace     *string `pulumi:"namespace"`
	NodesExpected *int    `pulumi:"nodesExpected"`
	NodesHealthy  *int    `pulumi:"nodesHealthy"`
	// An optional key-value map of strings passed directly to the CSI plugin to configure the volume.
	Parameters map[string]string `pulumi:"parameters"`
	// The ID of the CSI plugin that manages this volume.
	PluginId              *string `pulumi:"pluginId"`
	PluginProvider        *string `pulumi:"pluginProvider"`
	PluginProviderVersion *string `pulumi:"pluginProviderVersion"`
	Schedulable           *bool   `pulumi:"schedulable"`
	// An optional key-value map of strings used as credentials for publishing and unpublishing volumes.
	Secrets map[string]string `pulumi:"secrets"`
	// The type of the volume. Currently, only 'csi' is supported.
	Type *string `pulumi:"type"`
	// The unique ID of the volume, how jobs will refer to the volume.
	VolumeId *string `pulumi:"volumeId"`
}

type VolumeState struct {
	// Defines whether a volume should be available concurrently.
	//
	// Deprecated: use capability instead
	AccessMode pulumi.StringPtrInput
	// The storage API that will be used by the volume.
	//
	// Deprecated: use capability instead
	AttachmentMode pulumi.StringPtrInput
	// Capabilities intended to be used in a job. At least one capability must be provided.
	Capabilities VolumeCapabilityArrayInput
	// An optional key-value map of strings passed directly to the CSI plugin to validate the volume.
	Context             pulumi.StringMapInput
	ControllerRequired  pulumi.BoolPtrInput
	ControllersExpected pulumi.IntPtrInput
	ControllersHealthy  pulumi.IntPtrInput
	// If true, the volume will be deregistered on destroy.
	DeregisterOnDestroy pulumi.BoolPtrInput
	// The ID of the physical volume from the storage provider.
	ExternalId pulumi.StringPtrInput
	// Options for mounting 'block-device' volumes without a pre-formatted file system.
	MountOptions VolumeMountOptionsPtrInput
	// The display name of the volume.
	Name pulumi.StringPtrInput
	// The namespace in which to create the volume.
	Namespace     pulumi.StringPtrInput
	NodesExpected pulumi.IntPtrInput
	NodesHealthy  pulumi.IntPtrInput
	// An optional key-value map of strings passed directly to the CSI plugin to configure the volume.
	Parameters pulumi.StringMapInput
	// The ID of the CSI plugin that manages this volume.
	PluginId              pulumi.StringPtrInput
	PluginProvider        pulumi.StringPtrInput
	PluginProviderVersion pulumi.StringPtrInput
	Schedulable           pulumi.BoolPtrInput
	// An optional key-value map of strings used as credentials for publishing and unpublishing volumes.
	Secrets pulumi.StringMapInput
	// The type of the volume. Currently, only 'csi' is supported.
	Type pulumi.StringPtrInput
	// The unique ID of the volume, how jobs will refer to the volume.
	VolumeId pulumi.StringPtrInput
}

func (VolumeState) ElementType() reflect.Type {
	return reflect.TypeOf((*volumeState)(nil)).Elem()
}

type volumeArgs struct {
	// Defines whether a volume should be available concurrently.
	//
	// Deprecated: use capability instead
	AccessMode *string `pulumi:"accessMode"`
	// The storage API that will be used by the volume.
	//
	// Deprecated: use capability instead
	AttachmentMode *string `pulumi:"attachmentMode"`
	// Capabilities intended to be used in a job. At least one capability must be provided.
	Capabilities []VolumeCapability `pulumi:"capabilities"`
	// An optional key-value map of strings passed directly to the CSI plugin to validate the volume.
	Context map[string]string `pulumi:"context"`
	// If true, the volume will be deregistered on destroy.
	DeregisterOnDestroy *bool `pulumi:"deregisterOnDestroy"`
	// The ID of the physical volume from the storage provider.
	ExternalId string `pulumi:"externalId"`
	// Options for mounting 'block-device' volumes without a pre-formatted file system.
	MountOptions *VolumeMountOptions `pulumi:"mountOptions"`
	// The display name of the volume.
	Name *string `pulumi:"name"`
	// The namespace in which to create the volume.
	Namespace *string `pulumi:"namespace"`
	// An optional key-value map of strings passed directly to the CSI plugin to configure the volume.
	Parameters map[string]string `pulumi:"parameters"`
	// The ID of the CSI plugin that manages this volume.
	PluginId string `pulumi:"pluginId"`
	// An optional key-value map of strings used as credentials for publishing and unpublishing volumes.
	Secrets map[string]string `pulumi:"secrets"`
	// The type of the volume. Currently, only 'csi' is supported.
	Type *string `pulumi:"type"`
	// The unique ID of the volume, how jobs will refer to the volume.
	VolumeId string `pulumi:"volumeId"`
}

// The set of arguments for constructing a Volume resource.
type VolumeArgs struct {
	// Defines whether a volume should be available concurrently.
	//
	// Deprecated: use capability instead
	AccessMode pulumi.StringPtrInput
	// The storage API that will be used by the volume.
	//
	// Deprecated: use capability instead
	AttachmentMode pulumi.StringPtrInput
	// Capabilities intended to be used in a job. At least one capability must be provided.
	Capabilities VolumeCapabilityArrayInput
	// An optional key-value map of strings passed directly to the CSI plugin to validate the volume.
	Context pulumi.StringMapInput
	// If true, the volume will be deregistered on destroy.
	DeregisterOnDestroy pulumi.BoolPtrInput
	// The ID of the physical volume from the storage provider.
	ExternalId pulumi.StringInput
	// Options for mounting 'block-device' volumes without a pre-formatted file system.
	MountOptions VolumeMountOptionsPtrInput
	// The display name of the volume.
	Name pulumi.StringPtrInput
	// The namespace in which to create the volume.
	Namespace pulumi.StringPtrInput
	// An optional key-value map of strings passed directly to the CSI plugin to configure the volume.
	Parameters pulumi.StringMapInput
	// The ID of the CSI plugin that manages this volume.
	PluginId pulumi.StringInput
	// An optional key-value map of strings used as credentials for publishing and unpublishing volumes.
	Secrets pulumi.StringMapInput
	// The type of the volume. Currently, only 'csi' is supported.
	Type pulumi.StringPtrInput
	// The unique ID of the volume, how jobs will refer to the volume.
	VolumeId pulumi.StringInput
}

func (VolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*volumeArgs)(nil)).Elem()
}

type VolumeInput interface {
	pulumi.Input

	ToVolumeOutput() VolumeOutput
	ToVolumeOutputWithContext(ctx context.Context) VolumeOutput
}

func (*Volume) ElementType() reflect.Type {
	return reflect.TypeOf((**Volume)(nil)).Elem()
}

func (i *Volume) ToVolumeOutput() VolumeOutput {
	return i.ToVolumeOutputWithContext(context.Background())
}

func (i *Volume) ToVolumeOutputWithContext(ctx context.Context) VolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeOutput)
}

// VolumeArrayInput is an input type that accepts VolumeArray and VolumeArrayOutput values.
// You can construct a concrete instance of `VolumeArrayInput` via:
//
//          VolumeArray{ VolumeArgs{...} }
type VolumeArrayInput interface {
	pulumi.Input

	ToVolumeArrayOutput() VolumeArrayOutput
	ToVolumeArrayOutputWithContext(context.Context) VolumeArrayOutput
}

type VolumeArray []VolumeInput

func (VolumeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Volume)(nil)).Elem()
}

func (i VolumeArray) ToVolumeArrayOutput() VolumeArrayOutput {
	return i.ToVolumeArrayOutputWithContext(context.Background())
}

func (i VolumeArray) ToVolumeArrayOutputWithContext(ctx context.Context) VolumeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeArrayOutput)
}

// VolumeMapInput is an input type that accepts VolumeMap and VolumeMapOutput values.
// You can construct a concrete instance of `VolumeMapInput` via:
//
//          VolumeMap{ "key": VolumeArgs{...} }
type VolumeMapInput interface {
	pulumi.Input

	ToVolumeMapOutput() VolumeMapOutput
	ToVolumeMapOutputWithContext(context.Context) VolumeMapOutput
}

type VolumeMap map[string]VolumeInput

func (VolumeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Volume)(nil)).Elem()
}

func (i VolumeMap) ToVolumeMapOutput() VolumeMapOutput {
	return i.ToVolumeMapOutputWithContext(context.Background())
}

func (i VolumeMap) ToVolumeMapOutputWithContext(ctx context.Context) VolumeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeMapOutput)
}

type VolumeOutput struct{ *pulumi.OutputState }

func (VolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Volume)(nil)).Elem()
}

func (o VolumeOutput) ToVolumeOutput() VolumeOutput {
	return o
}

func (o VolumeOutput) ToVolumeOutputWithContext(ctx context.Context) VolumeOutput {
	return o
}

type VolumeArrayOutput struct{ *pulumi.OutputState }

func (VolumeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Volume)(nil)).Elem()
}

func (o VolumeArrayOutput) ToVolumeArrayOutput() VolumeArrayOutput {
	return o
}

func (o VolumeArrayOutput) ToVolumeArrayOutputWithContext(ctx context.Context) VolumeArrayOutput {
	return o
}

func (o VolumeArrayOutput) Index(i pulumi.IntInput) VolumeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Volume {
		return vs[0].([]*Volume)[vs[1].(int)]
	}).(VolumeOutput)
}

type VolumeMapOutput struct{ *pulumi.OutputState }

func (VolumeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Volume)(nil)).Elem()
}

func (o VolumeMapOutput) ToVolumeMapOutput() VolumeMapOutput {
	return o
}

func (o VolumeMapOutput) ToVolumeMapOutputWithContext(ctx context.Context) VolumeMapOutput {
	return o
}

func (o VolumeMapOutput) MapIndex(k pulumi.StringInput) VolumeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Volume {
		return vs[0].(map[string]*Volume)[vs[1].(string)]
	}).(VolumeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeInput)(nil)).Elem(), &Volume{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeArrayInput)(nil)).Elem(), VolumeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeMapInput)(nil)).Elem(), VolumeMap{})
	pulumi.RegisterOutputType(VolumeOutput{})
	pulumi.RegisterOutputType(VolumeArrayOutput{})
	pulumi.RegisterOutputType(VolumeMapOutput{})
}
